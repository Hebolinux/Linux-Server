# 定时任务

定时任务：按照时间周期进行自动操作

定时任务工具：

1. cronie：系统默认定时任务工具
    ```shell
    # 通过执行程序名称查找该程序属于那个软件包
    rpm -qf $(which crond)
    ```
2. atd：一次性定时任务工具
3. anacron：客户端工具类型，不是专业的服务端工具
## 定时任务实现类型

### 1. 系统定时任务

系统定时任务

1. 4个重要目录
- 任务周期:每小时 `/etc/cron.hourly/`
- 任务周期:每天 `/etc/cron.daily/`
- 任务周期:每周 `/etc/cron.weekly/`
- 任务周期:每月 `/etc/cron.monthly/`
将脚本直接放置在这些目录下即可周期性执行

2. 2个重要文件
`/etc/cron.deny`：阻止指定用户不能使用系统自带的定时任务服务
`/etc/crontab`：定时任务的参考说明文件。不要在此文件下直接编辑定时任务

日志文件切割处理`logrotate`任务是系统默认设置好的定时任务
```shell
less /etc/logrotate.conf
...
# rotate log files weekly    # 每周切割保存一次日志
weekly


# keep 4 weeks worth of backlogs    # 仅保留最近4周的日志数据
rotate 4


# create new (empty) log files after rotating old ones    # 旧日志数据切割保存后创建新的空日志文件
create


# use date as a suffix of the rotated file    # 文件保存的命名以日期结尾
dateext


# uncomment this if you want your log files compressed    # 压缩日志数据文件
#compress


# RPM packages drop log rotation information into this directory
include /etc/logrotate.d

/var/log/wtmp {    # 对指定日志数据文件自定义切割条件
    monthly    # 每月切割一次
    create 0664 root utmp    # 设置新建日志文件的权限、所属用户、所属组
        minsize 1M    # 切割日志文件最小1M大小
    rotate 1    # 只保留1个月的数据
}
...
```

### 2. 用户定时任务

定时任务的配置只有一个命令和一个文件

一个命令：crontab -- 设置或查看定时任务信息的命令

```shell
crontab --help
    -u <user>：指定执行该定时任务的用户身份
    -e：编写定时任务配置
    -l：显示定时任务配置文件信息
    -r：删除用户的所有定时任务
    -i：执行命令前提示
    -x <mask>：启动调试模式
```

一个文件：`/var/spool/cron/` -- 配置定时任务后会在此目录下发现对应用户名文件

### 3. 编写定时任务

1. 编写定时任务语法
```shell
 分  -  时  - 日   -  月   -  周            将要执行的命令
0~59 - 0~23 - 1~31 - 1~12 - 0~6            日期和周不能同时出现

crontab -e    # 编写定时任务
00 12 * * *    echo test >> /tmp/test.txt

more /var/spool/cron/root    # 查看配置文件
systemctl restart crond     # 重启定时任务服务，使配置生效
```

编写定时任务时建议使用crontab命令编辑，crontab会自动检测语法，直接编辑配置文件可能出错。编辑二者实现的效果是一致的

2.检测定时任务是否生效
```shell
date -s "11:59"     # 修改系统时间。等待定时任务时间执行
ls /tmp/    查看定时任务执行的结果
```
如果定时任务未生效，查看定时任务日志，

### 4. 定时任务相关文件

1. 定时任务服务配置文件所在目录 `/var/spool/cron/`
2. 定时任务服务运行日志文件 `/var/log/cron`
3. 定时任务黑名单 `/var/cron.deny`

### 5. 定时任务编写技巧

1. 定时任务配置文件中的符号信息

- *：每次    每分钟/每小时/每天/每月/每周
- */n：时间间隔    每隔n分钟/每隔n小时/每隔n天/每隔n月    没有每隔n周的写法
- n-m：连续时间范围    n到m分钟/n到m小时...
- n,m：不连续的时间范围    n分钟和m分钟/n小时与m小时...

注：有时可能会看到 `m/n * * * *` 这样的写法，这表示到m分钟的前n分钟执行操作，例如 `30/10 * * * *` 表示`1:30`的前10分钟执行操作，小时位是循环的，可以是`2:30`、`3:30`等

编写定时任务时，上一级时间有设置时，尽量对下级时间也要设置，例如每天中午12点应该写成 `00 12 * * *` ，即便没有对分钟有具体声明，也应该对其有具体设置，如果分钟位不进行设置，也就是`*`时，那么不仅每天中午12点会执行操作，每分钟也会执行一次操作

定时任务的注意事项
1. 在定时任务中不能识别一些特殊的符号信息。例如`` ` ``号、`.`号等 -- 使用脚本执行定时任务
2. 无论是文件名或是命令，编写定时任务时要使用绝对路径 -- 定时任务能识别的环境变量`$PATH=/usr/bin:/bin`
3. 每个定时任务都需要注释说明
4. 当操作的命令超过2个时，尽量使用脚本文件
5. 每个定时任务的结尾使用错误重定向将错误输出内容重定向到/dev/null，避免磁盘空间被占用
6. 在定时任务中，执行命令尽量不要产生输出信息 -- 正常的警告或提示信息输出仍会产生邮件提示，例如使用tar命令时，省略-v选项，尽量使用相对路径压缩


错误示范
```shell
# 特殊符号不识别
00 12 * * * cp /etc/hosts >> /tmp/backup/hosts_$(date +%F).txt

# 脚本文件未使用绝对路径
00 12 * * * bash ./test.sh

# 定时任务环境变量不同导致命令执行有问题
00 12 * * * ip address show eth0 > /tmp/backup/hosts_

00 12 * * * echo $PATH > /tmp/backup/hosts
```
执行定时任务时可能会收到邮件`You have mail in /var/spool/mail/root`，这个邮件是由postfix服务产生的，**定时任务执行出错时**就会产生错误邮件

如果不想显示收到邮件的提示可以选择关闭postfix服务，但关闭postfix服务后仍然会产生邮件，这时产生的邮件会暂时保存到`/var/spool/postfix/maildrop/`目录中，此目录下可能会产生大量小文件，占用过多的inode。重启postfix服务时会将`/var/spool/postfix/maildrop/`目录的文件处理掉

### 6. 定时任务编写规范

1. 直接在定时任务中书写命令

    a. 测试定时执行命令

    b. 编写定时任务信息

    c. 检查定时任务效果

    d. 排查定时任务问题

示例：编写时间同步的定时任务
```shell
yum install -y ntpdate

# 测试定时任务要执行的命令
ntpdate ntp1.aliyun.com        

# 编写定时任务信息
crontab -e
*/10 * * * * /usr/sbin/ntpdate ntp1.aliyun.com &> /dev/null        # 不输出任何信息

# 检查定时任务效果
1. 调整系统时间
2. 调整配置文件的时间

# 排查故障
关注日志信息 /var/log/cron
```

2. 直接在定时任务中调用脚本

    a. 测试定时执行脚本

        ```shell
        /bin/bash /Script_Path/test.sh    # 使用解释器命令测试脚本
        ```

    b. 编写定时任务信息

    c. 检查定时任务效果

    d. 排查定时任务问题


# 磁盘管理

1. 磁盘管理体系结构
2. 每个磁盘管理结构详解
3. 磁盘的两种分区方式
4. 实例
5. 磁盘相关命令
6. 系统安全

## 磁盘管理体系结构

磁盘体系结构分5层

第五层 ---- &ensp;&ensp;磁盘管理维护 &ensp;&ensp;&ensp;---- 管理磁盘命令

第四层 ---- &ensp;&ensp;&ensp;格式化磁盘 &ensp;&ensp;&ensp;&ensp;---- 格式化磁盘：格式化、文件系统、挂载知识，创建文件系统初始化inode和block

第三层 ---- &ensp;&ensp;&ensp;&ensp;磁盘分区 &ensp;&ensp;&ensp;&ensp;&ensp;---- 磁盘分区：分区知识，主、扩展、逻辑、分区表知识，分区命令fdisk、parted

第二层 ---- 完成RAID LVM等操作 ---- 磁盘阵列知识：RAID知识、软硬RAID、LVM知识

第一层 ---- &ensp;&ensp;&ensp;&ensp;物理磁盘 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;---- 物理磁盘知识：磁盘外部结构、接口、内部结构、工作原理、读写原理

### 磁盘第一层体系结构

#### 磁盘的外部结构

根据台式机与笔记本的区别，硬盘分为3.5和2.5英寸。一块机械硬盘主要由**盘片、机械臂、电子探头、主轴马达**组成
。所有的实际数据由盘片保存，读写数据需要通过电子探头完成。实际运行时，主轴马达带动盘片转动，机械臂通过径向运动伸展电子探头在盘片上进行读写操作

#### 磁盘的内部结构

- 磁头（Head）：磁头数量与盘面数量相同，采用径向运动读写数据
- 磁道（Track）：由多个同心圆组成，最外圈圆为0磁道。磁盘默认按照磁道查找数据，磁头的径向运动被称为寻道，径向运动属于机械运动，速度较慢
- 扇区（Sector）：扇区是**磁盘**最小的存储单位，block是**系统**最小的存储单位。默认磁盘扇区从1扇区开始，扇区大小为512字节
- 柱面（Cylinder）：不同盘面上相同的磁道组成的圆柱体，磁盘默认按照柱面进行读写。磁头之间的切换是电子切换，速度较快
- 单元块（Units）：表示单个柱面大小

磁盘查找数据时，会先从0磁道开始找，整个0磁道的单元块都找找不到数据才会切换磁道，此间，柱面内切换盘片查找数据时电子切换，柱面间切换磁道查找数据属于机械运动。读写皆是以柱面为单位进行读写，整个柱面数据写完后才会切换磁盘写

计算磁盘大小

```shell
fdisk -l    # 查看磁盘信息

Disk /dev/sda: 107.4 GB, 107374182400 bytes, 209715200 sectors
#        磁盘大小        以字节为单位的容量大小      扇区总数
Units = sectors of 1 * 512 = 512 bytes
#    单元块的计算方式，其中声明每隔扇区大小为512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
```

数据读写原理

1. 磁头开始读取 0磁头 0磁道 1扇区的数据（MBR 引导系统启动）
2. 磁头做电子运动，进行切换磁头，再读写数据 1磁头 0磁道
3. 磁头做机械运动（径向运动），移动磁头再读写数据 0磁头 1磁道

### 磁盘第二层结构-RAID、LVM

RAID（磁盘阵列）

作用：

1.提高数据的安全性
2.提高磁盘存储容量
3.提高磁盘存储效率

RAID的级别

- RAID 0：安全性差，容量无损失，读写效率高
- RAID 1：安全性高，容量损失一半，效率低
- RAID 5：安全性较高，容量损失，效率高

LVM

实现磁盘分区的弹性扩容和缩容

### 磁盘第三层结构-分区

现在常见的分区方式分2种：MSDOS与GPT。MSDOS分区方式中，磁盘的第一个扇区非常重要，该扇区保存重要数据，被称为MBR（Master Boot Record）格式，MSDOS出现比较早，此模式兼容大部分分区场景，但由于近年来磁盘容量不断增大，甚至部分大于2TB的硬盘分区让部分OS无法读写，因此后来推出了新的分区格式GPT

#### MSDOS（MBR）与GPT磁盘分区表（partition table）

通常文件系统的最小单位是柱面（Cylinder)，也就是分区时的最小单位，但GPT分区表可达到64bit记录功能，所以现在甚至可以使用扇区（sector）号来作为分区单位

##### MSDOS分区表格式与限制

早期Linux系统为兼容Windows的磁盘，使用了支持Windows的MBR方式处理开关机管理程序与分区表，而开关机管理程序与分区表都放在磁盘的第一个扇区，该扇区通常是512Bytes（旧磁盘扇区都是512Bytes大小），这个扇区中保存2个数据：

- 主引导记录（MBR）：可以安装开关机管理程序的地方，446Bytes
- 分区表（partition table）：记录整个硬盘的分区状态，64Bytes



#### 系统分区说明

fdisk
fdisk一般不对容量大于2T的磁盘执行操作，因为大于2T的磁盘不支持MBR引导

parted
parted命令没有磁盘容量的限制，磁盘容量大于2T时，parted使用GPT引导

主分区方式分4个区：/dev/sda1、/dev/sda2、/dev/sda3、/dev/sda4
扩展分区方式分区：/dev/sda1、/dev/sda2、/dev/sda3、/dev/sda5

系统启动引导记录（MBR主引导记录）：0磁头 0磁道 1扇区（512字节），MBR实际用于记录占用空间的容量是446字节，还有64字节用于记录DPT分区表信息、2字节用于分区结束标识（55AA）

系统分区类型说明：
1. 主分区（primary）：最多4个主分区，每个分区占用16字节
2. 扩展分区（extend）：最多只能存在1个扩展分区，扩展分区无法直接用于存储数据信息
3. 逻辑分区（logical）：逻辑分区存于扩展分区下，用于存放数据信息。逻辑分区可以有多个

#### 系统分区实践操作

##### fdisk

1. 创建分区环境
```shell
# 查看主机磁盘信息
fdisk -l    #有很大可能，热添加的硬盘无法直接被系统识别出来

# 重新扫描磁盘，这种方式可以避免主机重启
for i in /sys/class/scsi_host/host*/scan;do echo "- - -" > $i; done
```

2. fdisk分区处理
```shell
fdisk /dev/sdb  # 对/dev/sdb磁盘执行分区

Command (m for help): m    # 显示帮助信息
Command action
   c   toggle the dos compatibility flag    # 磁盘模式相关
   d   delete a partition   # 删除分区
   g   create a new empty GPT partition table   # 创建一个GPT的分区表
   l   list known partition types   # 列出已知的分区类型
   n   add a new partition  # 添加新分区
   p   print the partition table    # 显示分区表信息
   t   change a partition\'s system id    # 修改分区的类型
   v   verify the partition table   # 验证分区表。承载业务时尽量不要执行此操作，会加重磁盘的I/O负担

# 新建一个主分区
Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)    # 主分区
   e   extended    #扩展分区
Select (default p): p    # 默认是主分区
Partition number (1-4, default 1): 1    # 输入分区编号。主分区最多只有4个
First sector (2048-41943039, default 2048):     # 第一个分区的起始扇区位置。默认是2048
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-41943039, default 41943039): +10G   # 第一个分区给10G空间
Partition 1 of type Linux and of size 10 GiB is set

# 修改主分区的类型
Command (m for help): p    # 显示分区信息
Command (m for help): l    # 显示所有分区类型
Command (m for help): t    # 修改1分区的类型
Selected partition 1
Hex code (type L to list all codes): 8e    # 输入分区类型的ID
Changed type of partition 'Linux' to 'Linux LVM'

# 新建扩展分区
Command (m for help): n
Select (default p): e    # 创建一个扩展分区，并将剩余磁盘容量都给扩展分区

# 新建逻辑分区
Command (m for help): n
Partition type:
   p   primary (2 primary, 1 extended, 1 free)
   l   logical (numbered from 5)
Select (default p): l    # 1个分区表里只能由1个扩展分区，再分区也只能再扩展分区下新建逻辑分区
```

在CentOS6中直接使用`fdisk /dev/sdb`分区命令时会提示警告信息，提示使用`fdisk -cu /dev/sdb`选项进行分区，关闭特殊分区模式并以扇区为分区单位显示。CentOS6使用fdisk新建分区不会默认分配编号，必须手动输入编号

```shell
WARNING: DOS-compatible mode is deprecated. It's strongly recommended to
         switch off the mode (command 'c') and change display units to
         sectors (command 'u').
```

3. 重读分区表

使用fdisk工具只是将分区信息写入到磁盘，内核并不知道新的分区信息，因此，在格式化磁盘前必须使内核知晓新的分区信息。内核读取分区信息的方式有2种：

    1. 重启系统
    2. `partprobe /dev/sdb`

注：RHEL7.9系统环境似乎已经不再需要此步骤，使用fdisk分区完成后直接格式化分区无报错，挂载无报错

4. 格式化分区

```shell
# 格式化有多种文件系统格式可选，CentOS7常见的有ext4、xfs
mkfs.ext4 /dev/sdb1
```

CentOS6的分区格式化后会产生如下提示，表示文件系统将每39次挂载或180天自动检查一次。前面已经提及过，多数情况下不要对磁盘执行检查操作，会加重磁盘的I/O负载，因此，可以使用tune2fs命令对磁盘管理操作进行调整。CentOS7不存在此问题

示例：关闭系统磁盘自检

```shell
This filesystem will be automatically checked every 39 mounts or
180 days, whichever comes first. Use tune2fs -c or -i to override.

tune2fs -c 0 -i 0 /dev/sdb1     # 不对磁盘做检查
    -c：最大挂载次数。值为0或-1时不检查文件系统的挂载次数
    -i：两次文件系统检查之间的最长时间。值为0时禁用时间检查
```

5. 挂载分区

```shell
# 挂载点必须是目录，可以手动创建新目录，或利用已有目录
mount /dev/sdb1 /mnt
```

6. 永久挂载

使用mount命令挂载磁盘只是临时生效，系统重启后挂载失效，又需要重新手动挂载。此时就需要做到开机自动挂载，开机自动挂载分2种方式：

    1. 利用`/etc/rc.local`文件
    echo "mount /dev/sdb1 /mnt" >> /etc/rc.local

    2. 利用`/etc/fstab`文件
    UUID=68af6be2-bca6-4101-93ec-16ae96d729a1    /mnt/sdb1    ext4    defaults    0 0
               挂载的设备文件信息                   挂载点     文件系统  挂载选项  是否检查磁盘 是否备份磁盘数据

使用blkid命令可以查看磁盘的UUID号；使用mount命令挂载时可以通过`-o`（option）选项添加挂载选项，例如`mount -o ro /dev/sdb1 /mnt/`只读挂载，与直接写在`/etc/fstab`文件中的挂载选项起同样的作用，`/etc/fstab`文件中有多个选项时，使用`,`分隔多个选项

注：`/etc/rc.local`文件是为了兼容旧版本的RHEL系统服务，默认情况下此文件没有执行权限，所以需要授予可执行权限。与旧版本系统的init不同，systemd使用并行启动进程，所以此脚本也在系统引导期间被并行执行，不在其他服务之后运行，强烈建议创建专用的systemd服务规则，而不是使用此文件

##### parted

当磁盘容量超过2T时，使用fdisk工具会产生提示，对大于2T的磁盘不能在驱动器上使用DOS分区表格式，使用parted和GUID分区表格式（GPT）。并且强行使用fdisk对磁盘分区时，不论分多少个分区，所有分区容量加起来不会超过2T。同时，使用GPT分区类型时就没有所谓扩展分区的概念了，无论分多少个区都是主分区

1. 添加一个容量3T的硬盘

2. parted分区处理

parted命令分区是实时生效的，不需要保存退出，直接quit即可

```shell
parted /dev/sdb
GNU Parted 3.1
Using /dev/sdb
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) help   # 查看帮助
  mklabel,mktable LABEL-TYPE               create a new disklabel (partition table)     # 指定分区表类型
  mkpart PART-TYPE [FS-TYPE] START END     make a partition     # 创建新分区
  name NUMBER NAME                         name partition NUMBER as NAME
  print [devices|free|list,all|NUMBER]     display the partition table, available devices, free space, all found partitions, or a particular partition  # 显示分区信息
  quit                                     exit program     # 退出
  rm NUMBER                                delete partition NUMBER    # 删除分区


(parted) help mklabel   # 查看可用的分区表类型
(parted) mklabel gpt    # 指定gpt类型。此步骤会二次确认是否执行操作，因为此步骤会将磁盘上的数据抹除
(parted) print      # 检查是否修改成功
(parted) mkpart primary 0 2.5T      # 划分1个2.5T的主分区。此步骤会产生一个警告，未获取最佳性能，忽略即可

parted /dev/sdb print       # 查看分区信息
```

3. 重读分区表

```shell
partprobe /dev/sdb
```

4. 格式化分区

```shell
mkfs.ext4 /dev/sdb1
```

5. 挂载分区

```shell
mount /dev/sdb1 /mnt/sdb1
```

### 磁盘第四层结构-格式化

文件系统是存储和组织计算及数据文件的机制或方法

### 磁盘第五层结构-磁盘管理维护

服务器中安装tomcat时，会经常出现内存不够用（内存溢出）的情况。为了解决内存溢出的问题，系统通过swap分区临时将磁盘空间作为内存空间使用

示例1：扩展swap分区空间

```shell
dd if=/dev/zero of=/tmp/500M bs=100M count=5    # 创建500M大小的文件
    if：从指定文件读取；不能从标准输入读取
    of：写入指定文件；不是标准输出
    bs：一次最大读写字节
    count：复制几次
mkswap /tmp/500M    # 将该文件设置为交换区域
swapon /tmp/500M    # 指定用于交换分区的设备
swapon -s   # 显示已用交换设备的摘要
```

比较有意思的是`/dev/null`和`/dev/zero`2个特殊文件，此2个文件都指向*黑洞*，任何导入`/dev/null`的数据都是被导入黑洞中丢弃，而`/dev/zero`则是从黑洞中导出数据，通过`dd`命令限制导出数据量的大小

示例：dd命令扩展

```shell
dd if=/dev/sda of=/tmp/512B bs=512 count=1    # /dev/sda是系统所在的磁盘，此命令导出了启动扇区的数据
file /tmp/512B    # 查看该文件属性
od -xa /tmp/512B    # 查看启动扇区文件内容
```

#### 磁盘相关命令扩展

dumpe2fs：导出ext文件系统参数。xfs文件系统无法使用此命令查看

resize2fs：调整ext文件系统大小

fsck：检查磁盘命令。-a在一定程度上可以自动修复文件系统

od：查看二进制文件内容

sync：刷新文件系统缓冲区

iotop：查看系统的磁盘读写速度，显示进程占用swap的情况

htop：更高级的top命令

iftop：查询网卡流量情况，-i 监视指定网卡

#### 系统安全说明

1. 最小化安装:安装系统/安装软件
2. 保护好root:禁止root远程登录/修改远程连接端口号
3. 文件系统权限:给系统常用命令+i 无法新增内容/给系统配置文件+a
4. 给重要文件或命令做一个指纹