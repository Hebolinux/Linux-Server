# 定时任务

定时任务：按照时间周期进行自动操作

定时任务工具：

1. cronie：系统默认定时任务工具
    ```shell
    # 通过执行程序名称查找该程序属于那个软件包
    rpm -qf $(which crond)
    ```
2. atd：一次性定时任务工具
3. anacron：客户端工具类型，不是专业的服务端工具
## 定时任务实现类型

### 1. 系统定时任务

系统定时任务

1. 4个重要目录
- 任务周期:每小时 `/etc/cron.hourly/`
- 任务周期:每天 `/etc/cron.daily/`
- 任务周期:每周 `/etc/cron.weekly/`
- 任务周期:每月 `/etc/cron.monthly/`
将脚本直接放置在这些目录下即可周期性执行

2. 2个重要文件
`/etc/cron.deny`：阻止指定用户不能使用系统自带的定时任务服务
`/etc/crontab`：定时任务的参考说明文件。不要在此文件下直接编辑定时任务

日志文件切割处理`logrotate`任务是系统默认设置好的定时任务
```shell
less /etc/logrotate.conf
...
# rotate log files weekly    # 每周切割保存一次日志
weekly


# keep 4 weeks worth of backlogs    # 仅保留最近4周的日志数据
rotate 4


# create new (empty) log files after rotating old ones    # 旧日志数据切割保存后创建新的空日志文件
create


# use date as a suffix of the rotated file    # 文件保存的命名以日期结尾
dateext


# uncomment this if you want your log files compressed    # 压缩日志数据文件
#compress


# RPM packages drop log rotation information into this directory
include /etc/logrotate.d

/var/log/wtmp {    # 对指定日志数据文件自定义切割条件
    monthly    # 每月切割一次
    create 0664 root utmp    # 设置新建日志文件的权限、所属用户、所属组
        minsize 1M    # 切割日志文件最小1M大小
    rotate 1    # 只保留1个月的数据
}
...
```

### 2. 用户定时任务

定时任务的配置只有一个命令和一个文件

一个命令：crontab -- 设置或查看定时任务信息的命令

```shell
crontab --help
    -u <user>：指定执行该定时任务的用户身份
    -e：编写定时任务配置
    -l：显示定时任务配置文件信息
    -r：删除用户的所有定时任务
    -i：执行命令前提示
    -x <mask>：启动调试模式
```

一个文件：`/var/spool/cron/` -- 配置定时任务后会在此目录下发现对应用户名文件

### 3. 编写定时任务

1. 编写定时任务语法
```shell
 分  -  时  - 日   -  月   -  周            将要执行的命令
0~59 - 0~23 - 1~31 - 1~12 - 0~6            日期和周不能同时出现

crontab -e    # 编写定时任务
00 12 * * *    echo test >> /tmp/test.txt

more /var/spool/cron/root    # 查看配置文件
systemctl restart crond     # 重启定时任务服务，使配置生效
```

编写定时任务时建议使用crontab命令编辑，crontab会自动检测语法，直接编辑配置文件可能出错。编辑二者实现的效果是一致的

2.检测定时任务是否生效
```shell
date -s "11:59"     # 修改系统时间。等待定时任务时间执行
ls /tmp/    查看定时任务执行的结果
```
如果定时任务未生效，查看定时任务日志，

### 4. 定时任务相关文件

1. 定时任务服务配置文件所在目录 `/var/spool/cron/`
2. 定时任务服务运行日志文件 `/var/log/cron`
3. 定时任务黑名单 `/var/cron.deny`

### 5. 定时任务编写技巧

1. 定时任务配置文件中的符号信息

- *：每次    每分钟/每小时/每天/每月/每周
- */n：时间间隔    每隔n分钟/每隔n小时/每隔n天/每隔n月    没有每隔n周的写法
- n-m：连续时间范围    n到m分钟/n到m小时...
- n,m：不连续的时间范围    n分钟和m分钟/n小时与m小时...

注：有时可能会看到 `m/n * * * *` 这样的写法，这表示到m分钟的前n分钟执行操作，例如 `30/10 * * * *` 表示`1:30`的前10分钟执行操作，小时位是循环的，可以是`2:30`、`3:30`等

编写定时任务时，上一级时间有设置时，尽量对下级时间也要设置，例如每天中午12点应该写成 `00 12 * * *` ，即便没有对分钟有具体声明，也应该对其有具体设置，如果分钟位不进行设置，也就是`*`时，那么不仅每天中午12点会执行操作，每分钟也会执行一次操作

定时任务的注意事项
1. 在定时任务中不能识别一些特殊的符号信息。例如`` ` ``号、`.`号等 -- 使用脚本执行定时任务
2. 无论是文件名或是命令，编写定时任务时要使用绝对路径 -- 定时任务能识别的环境变量`$PATH=/usr/bin:/bin`
3. 每个定时任务都需要注释说明
4. 当操作的命令超过2个时，尽量使用脚本文件
5. 每个定时任务的结尾使用错误重定向将错误输出内容重定向到/dev/null，避免磁盘空间被占用
6. 在定时任务中，执行命令尽量不要产生输出信息 -- 正常的警告或提示信息输出仍会产生邮件提示，例如使用tar命令时，省略-v选项，尽量使用相对路径压缩


错误示范
```shell
# 特殊符号不识别
00 12 * * * cp /etc/hosts >> /tmp/backup/hosts_$(date +%F).txt

# 脚本文件未使用绝对路径
00 12 * * * bash ./test.sh

# 定时任务环境变量不同导致命令执行有问题
00 12 * * * ip address show eth0 > /tmp/backup/hosts_

00 12 * * * echo $PATH > /tmp/backup/hosts
```
执行定时任务时可能会收到邮件`You have mail in /var/spool/mail/root`，这个邮件是由postfix服务产生的，**定时任务执行出错时**就会产生错误邮件

如果不想显示收到邮件的提示可以选择关闭postfix服务，但关闭postfix服务后仍然会产生邮件，这时产生的邮件会暂时保存到`/var/spool/postfix/maildrop/`目录中，此目录下可能会产生大量小文件，占用过多的inode。重启postfix服务时会将`/var/spool/postfix/maildrop/`目录的文件处理掉

### 6. 定时任务编写规范

1. 直接在定时任务中书写命令

    a. 测试定时执行命令

    b. 编写定时任务信息

    c. 检查定时任务效果

    d. 排查定时任务问题

示例：编写时间同步的定时任务
```shell
yum install -y ntpdate

# 测试定时任务要执行的命令
ntpdate ntp1.aliyun.com        

# 编写定时任务信息
crontab -e
*/10 * * * * /usr/sbin/ntpdate ntp1.aliyun.com &> /dev/null        # 不输出任何信息

# 检查定时任务效果
1. 调整系统时间
2. 调整配置文件的时间

# 排查故障
关注日志信息 /var/log/cron
```

2. 直接在定时任务中调用脚本

    a. 测试定时执行脚本

        ```shell
        /bin/bash /Script_Path/test.sh    # 使用解释器命令测试脚本
        ```

    b. 编写定时任务信息

    c. 检查定时任务效果

    d. 排查定时任务问题


# 磁盘管理

1. 磁盘管理体系结构
2. 每个磁盘管理结构详解
3. 磁盘的两种分区方式
4. 实例
5. 磁盘相关命令
6. 系统安全

## 磁盘管理体系结构

磁盘体系结构分5层

第五层 ---- &ensp;&ensp;磁盘管理维护 &ensp;&ensp;&ensp;---- 管理磁盘命令

第四层 ---- &ensp;&ensp;&ensp;格式化磁盘 &ensp;&ensp;&ensp;&ensp;---- 格式化磁盘：格式化、文件系统、挂载知识，创建文件系统初始化inode和block

第三层 ---- &ensp;&ensp;&ensp;&ensp;磁盘分区 &ensp;&ensp;&ensp;&ensp;&ensp;---- 磁盘分区：分区知识，主、扩展、逻辑、分区表知识，分区命令fdisk、parted

第二层 ---- 完成RAID LVM等操作 ---- 磁盘阵列知识：RAID知识、软硬RAID、LVM知识

第一层 ---- &ensp;&ensp;&ensp;&ensp;物理磁盘 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;---- 物理磁盘知识：磁盘外部结构、接口、内部结构、工作原理、读写原理

### 磁盘第一层体系结构

#### 磁盘的外部结构

根据台式机与笔记本的区别，硬盘分为3.5和2.5英寸。一块机械硬盘主要由**盘片、机械臂、电子探头、主轴马达**组成
。所有的实际数据由盘片保存，读写数据需要通过电子探头完成。实际运行时，主轴马达带动盘片转动，机械臂通过径向运动伸展电子探头在盘片上进行读写操作

#### 磁盘的内部结构

- 磁头（Head）：磁头数量与盘面数量相同，采用径向运动读写数据
- 磁道（Track）：由多个同心圆组成，最外圈圆为0磁道。磁盘默认按照磁道查找数据，磁头的径向运动被称为寻道，径向运动属于机械运动，速度较慢
- 扇区（Sector）：扇区是**磁盘**最小的存储单位，block是**系统**最小的存储单位。默认磁盘扇区从1扇区开始，扇区大小为512字节
- 柱面（Cylinder）：不同盘面上相同的磁道组成的圆柱体，磁盘默认按照柱面进行读写。磁头之间的切换是电子切换，速度较快
- 单元块（Units）：表示单个柱面大小

磁盘查找数据时，会先从0磁道开始找，整个0磁道的单元块都找找不到数据才会切换磁道，此间，柱面内切换盘片查找数据时电子切换，柱面间切换磁道查找数据属于机械运动。读写皆是以柱面为单位进行读写，整个柱面数据写完后才会切换磁盘写

计算磁盘大小

```shell
fdisk -l    # 查看磁盘信息

Disk /dev/sda: 107.4 GB, 107374182400 bytes, 209715200 sectors
#        磁盘大小        以字节为单位的容量大小      扇区总数
Units = sectors of 1 * 512 = 512 bytes
#    单元块的计算方式，其中声明每隔扇区大小为512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
```

数据读写原理

1. 磁头开始读取 0磁头 0磁道 1扇区的数据（MBR 引导系统启动）
2. 磁头做电子运动，进行切换磁头，再读写数据 1磁头 0磁道
3. 磁头做机械运动（径向运动），移动磁头再读写数据 0磁头 1磁道

### 磁盘第二层结构-RAID、LVM

RAID（磁盘阵列）

作用：

1.提高数据的安全性
2.提高磁盘存储容量
3.提高磁盘存储效率

RAID的级别

- RAID 0：安全性差，容量无损失，读写效率高
- RAID 1：安全性高，容量损失一半，效率低
- RAID 5：安全性较高，容量损失，效率高

LVM

实现磁盘分区的弹性扩容和缩容

### 磁盘第三层结构-分区

现在常见的分区方式分2种：MSDOS与GPT。MSDOS分区方式中，磁盘的第一个扇区非常重要，该扇区保存重要数据，被称为MBR（Master Boot Record）格式，MSDOS出现比较早，此模式兼容大部分分区场景，但由于近年来磁盘容量不断增大，甚至部分大于2TB的硬盘分区让部分OS无法读写，因此后来推出了新的分区格式GPT

#### MSDOS（MBR）与GPT磁盘分区表（partition table）

通常文件系统的最小单位是柱面（Cylinder)，也就是分区时的最小单位，但GPT分区表可达到64bit记录功能，所以现在甚至可以使用扇区（sector）号来作为分区单位

##### MSDOS分区表格式与限制

早期Linux系统为兼容Windows的磁盘，使用了支持Windows的MBR方式处理开关机管理程序与分区表，而开关机管理程序与分区表都放在磁盘的第一个扇区，该扇区通常是512Bytes（旧磁盘扇区都是512Bytes大小），这个扇区中保存2个数据：

- 主引导记录（MBR）：可以安装开关机管理程序的地方，446Bytes
- 分区表（partition table）：记录整个硬盘的分区状态，64Bytes

由于分区表只有64Bytes，而每个分区需要16Bytes，因此最多能有4个分区，每个分区都会记录自身的起始与结束的柱面号

![磁盘分区表](https://github.com/Hebolinux/image/blob/main/Linux-Server/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E8%A1%A8.png)

假设设备上有一块硬盘，且这块硬盘只有400个柱面，将此硬盘分出4个分区，假设每100个柱面为1个分区。该硬盘在系统中的设备名是`/dev/sda`，实际命名还会在这个设备名后面接一个数字，这个数字与分区有关，例如`/dev/sda1`隶属于第一个分区，第一个分区记录1到100号柱面范围，那么数据要写入`/dev/sda1`时就会写入到这个磁盘的1到100号柱面之间

由于分区表只有64Bytes，最多只能记录4个分区，这4个分区被称为主分区（Primary）或扩展分区（Extended），总结：

- 分区仅针对64Bytes的区别表进行设置
- 磁盘默认的分区表仅能记录4个分区
- 这4个分区被称为主分区或扩展分区
- 分区的最小单位通常是柱面
- 系统要写入磁盘时，一定会参考分区表，才能对某个分区进行数据处理

如果分区类型都是主分区，那么分区表仅能记录4个分区，通过扩展分区的方式能够扩大这个分区数量

![扩展分区](https://github.com/Hebolinux/image/blob/main/Linux-Server/%E6%89%A9%E5%B1%95%E5%88%86%E5%8C%BA.png)

上图将扩展分区简化了，实际上扩展分区并不止占用一个分区，而是会分布在每个分区的最前面几个扇区用于记录分区信息。**扩展分区的实质是使用额外的扇区记录分区信息，扩展分区本身不能格式化**，由扩展分区分割出来的空间称为逻辑分区（logical partition），同时，由于逻辑分区是从扩展分区中分割出来的，所以逻辑分区可以使用的柱面范围只能是扩展分区设置的柱面范围。逻辑分区在系统中的设备名必须从`/dev/sda5`开始，因为`1~4`都是保留给主分区或扩展分区的

总结：

- 主分区最多存在4个分区
- 扩展分区最多存在1个分区
- 逻辑分区是由扩展分区延申的分区
- 扩展分区无法格式化，主分区和逻辑分区被格式化后能够用于读写数据
- 逻辑分区的数量根据不同的操作系统，在Linux系统中SATA硬盘已经可以突破63个分区数量

分区一般是以柱面为单位的连续的磁盘空间，如果要对一个磁盘完全分区并保留部分容量，那么P+P+P+E的分区方式是比较合适的，而考虑到磁盘的连续性，一般建议将扩展分区的柱面号码分配在最后面的柱面内

MBR分区表除了上述的主分区、扩展分区、逻辑分区需要注意以外，由于每组分区表只有16Bytes，容量相当有限，所以MBR分区表中的限制经常可以发下如下问题

- 操作系统无法识别2.2T以上的硬盘容量
- MBR仅有一个扇区，如果被破坏将无法或很难修复
- MBR内存放开关机管理程序的扇区仅446Bytes，无法容纳较多程序代码

> **关于扇区补充**

![磁盘结构](https://github.com/Hebolinux/image/blob/main/Linux-Server/%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.jpg)

大部分磁道示意图都是指向同心圆的一条线，可能会给人一种错觉，就是那条线就是磁道。但磁道实际上不是*同心圆*，而是*同心圆环*

每个磁道上的扇区数目一样吗：早期的磁盘每个磁道上的扇区数目是一样的，限制了磁盘的容量；后来为了增大磁盘容量采用了新技术，越往外每磁道的扇区数目越多，但单个扇区大小始终一样

#### GUID partition table（GPT分区表）

过去一个扇区大小是512Bytes，现在已有4K的扇区设计出现，为了兼容所有磁盘，因此在扇区的定义上大多使用逻辑块地址（Logical Block Address,LBA）来处理。GPT将所有磁盘的扇区以LBA（预设为512Bytes）来规划，第一个LBA称为LBA0

GPT使用34个LBA扇区来记录分区信息，除了前面的34个LBA之外，磁盘最后33个LBA也用于备份，相比较MBR仅使用第一个512Bytes扇区来记录分区信息更加安全

![GPT分区表结构]()

- LBA0（MBR兼容扇区）

    与MBR模式相似，此扇区分为2部分，一是与MBR相同的存储开关机管理程序的446Bytes区域、二是原本MBR用于存储分区表的64Bytes，在这64Bytes里放入了一个特殊标识，用于表示此磁盘是GPT的分区格式。不支持GPT分区表的磁盘管理程序无法识别这个磁盘，除非用户有特殊要求要处理这个磁盘，否则管理程序不能修改分区信息

- LBA1（GPT表头记录）

    基本分区表本身的位置与大小，同时记录备份GPT分区表（磁盘末尾的33个扇区）的存放位置和分区表的校验机制码（CRC32），OS根据校验码判断GPT是否正确，如果错误可以通过这个扇区找到备份的GPT分区表来回复GPT的正常运转

- LBA2\~33（实际记录分区信息）

    从LBA2扇区开始，**每个LBA可以记录4个分区信息，所以在默认情况下，共可以有4\*32=128个分区**。由于每个LBA有512Bytes，因此每个分区记录用到128 Bytes的空间，除了每个分区记录所需要的识别码与相关的信息之外，**GPT在每个分区记录中分别提供了64bits来记录开始/结束的扇区号**，因此GPT分区表对于单个分区的最大容量限制在*2^64 \* 512Bytes = 8ZB*

GPT分区模式可以提供128个分区，Linux的核心配置记录中，过去针对单一磁盘最多只能达到15个分区，现在由于Linux Kernel通过udev等方式的处理，已经没有这个限制。GPT分区模式没有主分区、扩展分区、逻辑分区的概念，每个分区都能够独立存在，所以每一个分区都被视为主分区

新版的Linux大多能够识别GPT分区表，但在磁盘管理工具上，fdisk不识别GPT，要使用GPT需要操作gdisk或parted工具，开关机管理程序上，grub第一版不识别GPT，需要grub2才识别。另外，不是所有的OS或硬件都能识别GPT，能否读写GPT格式又与开机检测程序有关，也就是BIOS与UEFI

##### 开机流程中的BIOS与UEFI开机检测程序

在计算机硬件中提及，没有软件的硬件是无用的，为了硬件资源的合理分配而产生了操作系统这个软件，由OS控制所有硬件并提供核心功能，由此识别磁盘内的文件系统，进一步读取磁盘内的软件程序。但OS本身也只是个软件，硬件是如何识别并运行OS的？这就需要涉及到开机程序，目前主机在加载硬件驱动方面的程序主要有早期的BIOS与新的UEFI两种机制

**BIOS 搭配 MBR/GPT 的开机流程**

在计算机硬件中有提及BIOS与CMOS，CMOS记录各项硬件的参数选项，BIOS是写入主板的一个固件。BIOS就是开机时主机会主动执行的第一个程序。BIOS会读取主机的存储设备，以硬盘为例，BIOS会根据使用者的设置读取能够开机的硬盘，并**读取到该硬盘的第一个扇区的MBR位置，MBR这个仅有446Bytes的磁盘容量内放置了最基本的开机管理程序**，此时BIOS的工作完成，接下来就是MBR内的开机管理程序的工作

**开机管理程序的目的在于载入（load）核心程序**，开机管理程序时OS在安装时提供的，所以其识别磁盘内的的文件系统格式，因此能够读取核心程序，接下来就是核心程序的工作，开机管理程序与BIOS工作完成，之后就是OS的工作

总结简述整个开机流程到操作系统的动作：

1. BIOS：开机主动执行的固件，识别第一个可开机的设备（大概率是硬盘）
2. MBR：第一个可开机设备的第一个扇区内的主引导记录区，内含开机管理程序
3. 开机管理程序（boot loader）：一个可读取执行核心程序的软件
4. 核心程序：开始操作系统的功能

关于第2点，如果分区表是GPT格式，那么BIOS也能够从LBA0的MBR兼容区域读取到第一阶段的开机管理程序码，如果开机管理程序能够识别GPT的话，那么使用BIOS同样能够读取到正确的操作系统核心，如果开机管理程序无法识别GPT，例如Windows XP，则无法读取核心程序，开机失败

由此可知，BIOS与MBR都是硬件本身支持的功能，`Boot Loader`则是由OS安装在MBR上的一个软件。由于MBR仅有446Bytes，所以这个开机管理程序是非常小的，`Boot Loader`的主要功能有：

- 提供选单：用户可以选择不同的开机选项
- 加载核心程序：直接指向可开机的设备的程序开始OS
- 转交其他loader：将开机管理程序的功能转交给其他loader负责

第3点是多系统的重要功能，表示主机内可以具备2个以上的开机管理程序。硬盘只有一个MBR，但是**开机管理程序除了可以安装在MBR以外，还可以安装在每个分区的开机扇区**

例如，电脑中仅一块硬盘，切成四个分区，分区一、二分别安装Windows及Linux，假设MBR内安装的时可同时识别Windows/Linux操作系统的开机管理程序，那么整个流程如下

![开机管理程序]()

MBR的开机管理程序提供两个选单，选单一（M1）直接加载Windows的核心程序开机；选单二（M2）将开机管理程序转交给第二个分区的开机扇区。用户开机时选择选单二时，整个开机管理工作就会交给第二个分区的开机管理程序，第二个开机管理程序启动后就只有一个开机选单，使用Linux核心程序开机。综上总结：

- 每个分区都有自己的开机扇区
- 实际可开机的核心程序放置在各自的分区内
- loader仅识别自己系统分区内的可开机核心程序，以及其他loader
- loader可以直接指向或者间接将管理权转交给另一个管理程序



#### 系统分区说明

fdisk
fdisk一般不对容量大于2T的磁盘执行操作，因为大于2T的磁盘不支持MBR引导

parted
parted命令没有磁盘容量的限制，磁盘容量大于2T时，parted使用GPT引导

主分区方式分4个区：/dev/sda1、/dev/sda2、/dev/sda3、/dev/sda4
扩展分区方式分区：/dev/sda1、/dev/sda2、/dev/sda3、/dev/sda5

系统启动引导记录（MBR主引导记录）：0磁头 0磁道 1扇区（512字节），MBR实际用于记录占用空间的容量是446字节，还有64字节用于记录DPT分区表信息、2字节用于分区结束标识（55AA）

系统分区类型说明：
1. 主分区（primary）：最多4个主分区，每个分区占用16字节
2. 扩展分区（extend）：最多只能存在1个扩展分区，扩展分区无法直接用于存储数据信息
3. 逻辑分区（logical）：逻辑分区存于扩展分区下，用于存放数据信息。逻辑分区可以有多个

#### 系统分区实践操作

##### fdisk

1. 创建分区环境
```shell
# 查看主机磁盘信息
fdisk -l    #有很大可能，热添加的硬盘无法直接被系统识别出来

# 重新扫描磁盘，这种方式可以避免主机重启
for i in /sys/class/scsi_host/host*/scan;do echo "- - -" > $i; done
```

2. fdisk分区处理
```shell
fdisk /dev/sdb  # 对/dev/sdb磁盘执行分区

Command (m for help): m    # 显示帮助信息
Command action
   c   toggle the dos compatibility flag    # 磁盘模式相关
   d   delete a partition   # 删除分区
   g   create a new empty GPT partition table   # 创建一个GPT的分区表
   l   list known partition types   # 列出已知的分区类型
   n   add a new partition  # 添加新分区
   p   print the partition table    # 显示分区表信息
   t   change a partition\'s system id    # 修改分区的类型
   v   verify the partition table   # 验证分区表。承载业务时尽量不要执行此操作，会加重磁盘的I/O负担

# 新建一个主分区
Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)    # 主分区
   e   extended    #扩展分区
Select (default p): p    # 默认是主分区
Partition number (1-4, default 1): 1    # 输入分区编号。主分区最多只有4个
First sector (2048-41943039, default 2048):     # 第一个分区的起始扇区位置。默认是2048
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-41943039, default 41943039): +10G   # 第一个分区给10G空间
Partition 1 of type Linux and of size 10 GiB is set

# 修改主分区的类型
Command (m for help): p    # 显示分区信息
Command (m for help): l    # 显示所有分区类型
Command (m for help): t    # 修改1分区的类型
Selected partition 1
Hex code (type L to list all codes): 8e    # 输入分区类型的ID
Changed type of partition 'Linux' to 'Linux LVM'

# 新建扩展分区
Command (m for help): n
Select (default p): e    # 创建一个扩展分区，并将剩余磁盘容量都给扩展分区

# 新建逻辑分区
Command (m for help): n
Partition type:
   p   primary (2 primary, 1 extended, 1 free)
   l   logical (numbered from 5)
Select (default p): l    # 1个分区表里只能由1个扩展分区，再分区也只能再扩展分区下新建逻辑分区
```

在CentOS6中直接使用`fdisk /dev/sdb`分区命令时会提示警告信息，提示使用`fdisk -cu /dev/sdb`选项进行分区，关闭特殊分区模式并以扇区为分区单位显示。CentOS6使用fdisk新建分区不会默认分配编号，必须手动输入编号

```shell
WARNING: DOS-compatible mode is deprecated. It's strongly recommended to
         switch off the mode (command 'c') and change display units to
         sectors (command 'u').
```

3. 重读分区表

使用fdisk工具只是将分区信息写入到磁盘，内核并不知道新的分区信息，因此，在格式化磁盘前必须使内核知晓新的分区信息。内核读取分区信息的方式有2种：

    1. 重启系统
    2. `partprobe /dev/sdb`

注：RHEL7.9系统环境似乎已经不再需要此步骤，使用fdisk分区完成后直接格式化分区无报错，挂载无报错

4. 格式化分区

```shell
# 格式化有多种文件系统格式可选，CentOS7常见的有ext4、xfs
mkfs.ext4 /dev/sdb1
```

CentOS6的分区格式化后会产生如下提示，表示文件系统将每39次挂载或180天自动检查一次。前面已经提及过，多数情况下不要对磁盘执行检查操作，会加重磁盘的I/O负载，因此，可以使用tune2fs命令对磁盘管理操作进行调整。CentOS7不存在此问题

示例：关闭系统磁盘自检

```shell
This filesystem will be automatically checked every 39 mounts or
180 days, whichever comes first. Use tune2fs -c or -i to override.

tune2fs -c 0 -i 0 /dev/sdb1     # 不对磁盘做检查
    -c：最大挂载次数。值为0或-1时不检查文件系统的挂载次数
    -i：两次文件系统检查之间的最长时间。值为0时禁用时间检查
```

5. 挂载分区

```shell
# 挂载点必须是目录，可以手动创建新目录，或利用已有目录
mount /dev/sdb1 /mnt
```

6. 永久挂载

使用mount命令挂载磁盘只是临时生效，系统重启后挂载失效，又需要重新手动挂载。此时就需要做到开机自动挂载，开机自动挂载分2种方式：

    1. 利用`/etc/rc.local`文件
    echo "mount /dev/sdb1 /mnt" >> /etc/rc.local

    2. 利用`/etc/fstab`文件
    UUID=68af6be2-bca6-4101-93ec-16ae96d729a1    /mnt/sdb1    ext4    defaults    0 0
               挂载的设备文件信息                   挂载点     文件系统  挂载选项  是否检查磁盘 是否备份磁盘数据

使用blkid命令可以查看磁盘的UUID号；使用mount命令挂载时可以通过`-o`（option）选项添加挂载选项，例如`mount -o ro /dev/sdb1 /mnt/`只读挂载，与直接写在`/etc/fstab`文件中的挂载选项起同样的作用，`/etc/fstab`文件中有多个选项时，使用`,`分隔多个选项

注：`/etc/rc.local`文件是为了兼容旧版本的RHEL系统服务，默认情况下此文件没有执行权限，所以需要授予可执行权限。与旧版本系统的init不同，systemd使用并行启动进程，所以此脚本也在系统引导期间被并行执行，不在其他服务之后运行，强烈建议创建专用的systemd服务规则，而不是使用此文件

##### parted

当磁盘容量超过2T时，使用fdisk工具会产生提示，对大于2T的磁盘不能在驱动器上使用DOS分区表格式，使用parted和GUID分区表格式（GPT）。并且强行使用fdisk对磁盘分区时，不论分多少个分区，所有分区容量加起来不会超过2T。同时，使用GPT分区类型时就没有所谓扩展分区的概念了，无论分多少个区都是主分区

1. 添加一个容量3T的硬盘

2. parted分区处理

parted命令分区是实时生效的，不需要保存退出，直接quit即可

```shell
parted /dev/sdb
GNU Parted 3.1
Using /dev/sdb
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) help   # 查看帮助
  mklabel,mktable LABEL-TYPE               create a new disklabel (partition table)     # 指定分区表类型
  mkpart PART-TYPE [FS-TYPE] START END     make a partition     # 创建新分区
  name NUMBER NAME                         name partition NUMBER as NAME
  print [devices|free|list,all|NUMBER]     display the partition table, available devices, free space, all found partitions, or a particular partition  # 显示分区信息
  quit                                     exit program     # 退出
  rm NUMBER                                delete partition NUMBER    # 删除分区


(parted) help mklabel   # 查看可用的分区表类型
(parted) mklabel gpt    # 指定gpt类型。此步骤会二次确认是否执行操作，因为此步骤会将磁盘上的数据抹除
(parted) print      # 检查是否修改成功
(parted) mkpart primary 0 2.5T      # 划分1个2.5T的主分区。此步骤会产生一个警告，未获取最佳性能，忽略即可

parted /dev/sdb print       # 查看分区信息
```

3. 重读分区表

```shell
partprobe /dev/sdb
```

4. 格式化分区

```shell
mkfs.ext4 /dev/sdb1
```

5. 挂载分区

```shell
mount /dev/sdb1 /mnt/sdb1
```

### 磁盘第四层结构-格式化

文件系统是存储和组织计算及数据文件的机制或方法

### 磁盘第五层结构-磁盘管理维护

服务器中安装tomcat时，会经常出现内存不够用（内存溢出）的情况。为了解决内存溢出的问题，系统通过swap分区临时将磁盘空间作为内存空间使用

示例1：扩展swap分区空间

```shell
dd if=/dev/zero of=/tmp/500M bs=100M count=5    # 创建500M大小的文件
    if：从指定文件读取；不能从标准输入读取
    of：写入指定文件；不是标准输出
    bs：一次最大读写字节
    count：复制几次
mkswap /tmp/500M    # 将该文件设置为交换区域
swapon /tmp/500M    # 指定用于交换分区的设备
swapon -s   # 显示已用交换设备的摘要
```

比较有意思的是`/dev/null`和`/dev/zero`2个特殊文件，此2个文件都指向*黑洞*，任何导入`/dev/null`的数据都是被导入黑洞中丢弃，而`/dev/zero`则是从黑洞中导出数据，通过`dd`命令限制导出数据量的大小

示例：dd命令扩展

```shell
dd if=/dev/sda of=/tmp/512B bs=512 count=1    # /dev/sda是系统所在的磁盘，此命令导出了启动扇区的数据
file /tmp/512B    # 查看该文件属性
od -xa /tmp/512B    # 查看启动扇区文件内容
```

#### 磁盘相关命令扩展

dumpe2fs：导出ext文件系统参数。xfs文件系统无法使用此命令查看

resize2fs：调整ext文件系统大小

fsck：检查磁盘命令。-a在一定程度上可以自动修复文件系统

od：查看二进制文件内容

sync：刷新文件系统缓冲区

iotop：查看系统的磁盘读写速度，显示进程占用swap的情况

htop：更高级的top命令

iftop：查询网卡流量情况，-i 监视指定网卡

#### 系统安全说明

1. 最小化安装:安装系统/安装软件
2. 保护好root:禁止root远程登录/修改远程连接端口号
3. 文件系统权限:给系统常用命令+i 无法新增内容/给系统配置文件+a
4. 给重要文件或命令做一个指纹