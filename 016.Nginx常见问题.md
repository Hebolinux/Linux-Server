# 一、Nginx多Server优先级

在开始处理一个http请求时，nginx会取出header头部的Host变量，与nginx.conf中每个server的server_name进行匹配，由此决定到底由哪个server来处理这个请求。但nginx如果配置多个相同的server_name，会导致server_name出现优先级访问冲突

1. 准备nginx对应配置文件

```shell
[root@web01 ~]# vim /usr/local/nginx/conf.d/web01.example.com.conf
server {
        listen 80;
        server_name localhost test1.com;

        location / {
                root /usr/local/nginx/html/;
                index test1.html;
        }
}
server {
        listen 80;
        server_name localhost test2.com;

        location / {
                root /usr/local/nginx/html/;
                index test2.html;
        }
}
server {
        listen 80;
        server_name localhost test3.com;

        location / {
                root /usr/local/nginx/html/;
                index test3.html;
        }
}
```

2. 准备站点环境

```shell
[root@web01 ~]# echo "test1" > /usr/local/nginx/html/test1.html
[root@web01 ~]# echo "test2" > /usr/local/nginx/html/test2.html
[root@web01 ~]# echo "test3" > /usr/local/nginx/html/test3.html
[root@web01 ~]# systemctl restart nginx	# 此时做nginx语法检测会有提示localhost域名冲突，忽略警告
```

3. 测试访问效果

```shell
[root@web01 ~]# curl localhost	# 用户首次访问返回code1

# 将web01的所有.conf配置文件注释，并调整测试配置文件内的test1的顺序
[root@web01 ~]# curl localhost  # 返回的值是最靠前的test配置值
```

在做好本地hosts文件解析的前提下，通过域名访问三个server正常，但通过IP地址直接访问web01节点时，Nginx排序最靠前的配置文件会生效，通过调整配置文件的排序的先后顺序可以测试

4. ServerName优先级结论

当用户请求的域名能与web节点中的多个server_name匹配时，Nginx会通过匹配优先级来选择server区块来处理，优先级顺序由高到低如下

1. 所有字符完全匹配的server_name
2. 通配符在前的server_name，如*.example.com
3. 通配符在后的server_name，如web.example.*
4. 使用正则表达式匹配的server_name
5. 如果全都没有匹配到，将选择在listen配置项后加入[default_server]的server块
6. 如果没写[default_server]，那么会匹配listen端口的第一个server块的配置文件

# 二、Nginx禁止IP直接访问

当用户通过IP或未知域名来访问站点时，希望Nginx能够禁止显示任何有效内容，可以给用户返回500，许多机房会要求站点关闭空主机头，防止未经过备案的域名指向站点

1. 设置IP访问默认server块

```shell
[root@web01 ~]# vim /usr/local/nginx/conf.d/web01.example.com.conf
...
server {
        listen 80 default_server;   # 设置为空主机头时默认返回的server区块
        server_name _;

        location / {
                root /usr/local/nginx/html/;
                index test4.html;
        }
}
[root@web01 ~]# echo "test4" > /usr/local/nginx/html/test4.html
[root@web01 ~]# systemctl restart nginx
```

2. 访问测试

```shell
[root@web01 ~]# curl 172.16.1.7 # 直接通过IP访问获取结果
```

3. 禁止直接通过IP访问

```shell
[root@web01 ~]# vim /usr/local/nginx/conf.d/web01.example.com.conf
server {
        listen 80 default_server;
        server_name _;
        return 503;
        # return 302 http://test1.com;  # 导流
}
```

除了禁止直接通过IP访问站点，还有一种用的比较多的方式就是*导流*，将流量指向站点首页

# 三、Nginx包含文件include

一台服务器的多个server站点如果都写在某一个或集中写在数个配置文件中，会导致配置文件变得庞大且可读性差，使后期维护难度增大；对于部分站点的调整和启停，集中式的配置文件中需要手动去注释配置文件，风险更高，通过include直接调整配置文件的方式更加便捷

# 四、Nginx路径root与alias

root与alias路径匹配主要区别在于nginx如何解释location的uri，这会使两者分别以不同的方式将请求映射到服务器路径上，alias是一个目录别名的定义，root则是最上层目录的定义

- root的处理结果：root路径+location路径
- alias的处理结果：使用alias路径替换location路径

```shell
[root@web01 ~]# vim /usr/local/nginx/conf.d/web01.example.com.conf
server {
        listen 80;
        server_name test5.com;

        location / {
                root /usr/local/nginx/html/;
                index jc.html;
        }

        location /nginx.png {
                alias /usr/local/nginx/html/images/;
                index nginx.png;
        }
}
```

经过测试，正则表达式的location匹配配合alias使用，无法获取到想要的结果，例如`location ~* ^.*\.(png|jpg|gif)$`、`location ~ \.(png|jpg|gif)$`、`location ~ \.png$`等正则匹配规则都进行尝试了，结果都不尽如人意

# 五、Nginx try_file路径匹配