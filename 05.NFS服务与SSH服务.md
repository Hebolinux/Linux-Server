# NFS

NFS存储在集群中用于保存静态资源数据。NFS主要功能是通过*局域网络*在不同主机间共享文件，用于企业集群架构中，如果是大型网站，会用到更复杂的分布式文件系统FastDFS（4K~500M的小文件，音频、小说、视频），Glusterfs（大文件，iso镜像），HDFS

**NFS主要用于解决web静态资源的一致性和资源共享问题**，避免web服务器的磁盘空间浪费，但它不能解决网站访问的延时问题，甚至会扩展大这个问题

## NFS写入原理

[![NFS写入原理](https://s1.ax1x.com/2022/11/26/zNiudK.png)](https://imgse.com/i/zNiudK)

NFS服务端本地写入，当用户执行mkdir命令，该命令会调用shell解释器翻译给内核，内核解析完成后驱动对应的硬件设备

NFS远程写入实现过程

1. 用户进程访问NFS客户端，使用不同的函数封装不同的操作命令
2. NFS客户端通过TCP/IP协议传输数据到NFS服务端
3. NFS服务端接收请求后，会先调用portmap进程进行端口映射
4. nfsd进程用于判断NFS客户端是否拥有权限连接NFS服务端
5. Rpc.mount进程判断客户端是否有具备文件的操作权限
6. idmap进程实现用户的映射和压缩
7. 最后NFS服务端会将对应请求的函数解封装转换为本地能识别的命令，传递至内核，由内核驱动硬件

从NFS的远程写入过程中，无论客户端操作系统是什么操作系统平台并不重要，客户端的命令首先都需要交给函数进行封装，函数传输到服务端后再进行识别；rpc是一个远程过程调用，使用nfs必须有rpc服务

- Rpc.nfsd：基本的NFS守护进程，主要功能是管理客户端是否能够登录服务器
- Rpc.mount：主要功能是管理NFS的文件系统。当客户端顺利通过nfsd登录NFS服务器后，在使用NFS服务所提供的文件签，还必须通过文件使用权限的验证。它会读取NFS的配置文件/etc/exports来对比客户端权限
- Portmap：主要功能是进行端口映射工作，其本身默认监听111端口

## NFS服务安装

1. 安装

```shell
[root@nfs ~]# yum install -y nfs-utils	# rpc包会被作为nfs的依赖包一起安装
[root@nfs ~]# rpm -qa rpcbind		# 检查rpc包
[root@nfs ~]# systemctl status rpcbind	# rpc安装后默认会设置为开机自启
```

2. 配置

NFS主配置文件`/etc/exports`，NFS配置文件语法格式：`共享目录 NFS客户端地址(客户端权限)`

示例：将nfs服务端的`/data`目录共享给`172.16.1.0/24`网段的所有主机

1. 所有客户端主机都具备读写权限
2. 将数据写入NFS服务器的硬盘中后才会结束操作，最大限度保证数据不丢失
3. 将所有用户映射为本地的匿名用户（nfsnobody）

```shell
[root@nfs ~]# more /etc/exports
/data	172.16.1.0/24(rw,sync,all_squash)

[root@nfs ~]# mkdir /data
[root@nfs ~]# firewall-cmd --add-service=nfs --permanent
[root@nfs ~]# firewall-cmd --add-service=rpc-bind --permanent
[root@nfs ~]# firewall-cmd --add-service=mountd --permanent
[root@nfs ~]# firewall-cmd --reload
```

3. 启动

```shell
systemctl start nfs-server
systemctl enable nfs-server
```

4. 检测

NFS服务启动后，`/var/lib/nfs/etab`内会记录NFS的共享配置信息，如果此文件为空，则配置文件可能有误，查看此文件时能看到大量权限参数，除了手动配置的参数以外，其他的参数都是NFS默认添加的

```shell
[root@nfs ~]# more /var/lib/nfs/etab
[root@nfs ~]# ss -lntp | column -t	# 查看端口
```

5. 客户端挂载

NFS通过RPC协议进行交互，所以客户端也必须具备rpcbind服务，除此以外，nfs-utils包中仍包含一些客户端要使用到的命令，例如showmount等

```shell
[root@web01 ~]# yum install -y nfs-utils
[root@web01 ~]# showmount -e 172.16.1.31	# 检查是否存在共享内容
[root@web01 ~]# mount -t nfs 172.16.1.31:/data /opt
[root@web01 ~]# df -h	# 查看挂载
```

此时NFS客户端连接挂载完毕，但客户端往共享目录里写入数据时会提示权限错误，客户端连接服务端的时候会经过两层验证，nfsd会检测客户端是否能够连接成功，mount会检测客户端对共享目录的权限。在上例中，mount的权限是rw，这两个检测都没有问题，因此，提示权限错误是由于主配置文件中，客户端的另一个权限参数all_squash导致

all_squash参数表示将所有客户端的用户压缩成一个匿名用户，这个匿名用户的uid和gid都是65534（nfsnobody)。所以，任何一个客户端的指令到达服务端后，都会被NFS服务交给这个匿名用户进行接封装再执行，但由于服务端的共享目录是由root创建，所以匿名用户没有权限操作共享目录，重新更改共享目录的授权即可。关于匿名用户的信息，在`/var/lib/nfs/etab`文件中也有记录

上例挂载属于临时操作，永久挂载需要写入`/etc/fstab`，但该文件一旦写入错误就可能导致设备重启时，系统启动失败，所以写入`/etc/fstab`文件后还需要使用`mount -a`命令测试是否能够正常挂载

## NFS服务端参数

在一般工作场景下，通常NFS服务端共享只是普通的静态数据，不需要执行`suid、exec`等权限，挂载的这个文件系统只能作为存取数据用，无法执行程序，对于服务端或客户端而言也增加了安全性

```shell
# 通过mount -o选项指定挂载参数，增加安全性能
mount -t nfs -o nosuid,noexec,nodev 172.16.1.31:/data /opt

# 禁止更新目录及文件时间戳挂载，一定程度上提升性能
mount -t nfs -o noatime,nodiratime 172.16.1.31:/data /opt
```

这两个选项对于现在的服务器架构而言，基本不需要添加这两个配置，硬盘读写纪录时间戳一定程度上会影响磁盘I/O，CDN能够解决这个问题

### NFS配置详解

|nfs共享参数|参数作用|
|---|---|
|rw|读写权限|
|ro|只读权限|
|root_squash|当NFS客户端以root账户访问时，映射为NFS服务端的匿名用户（不常用）|
|no_root_squash|当NFS客户端以root账户访问时，映射为NFS服务端的root用户（不常用）|
|all_squash|当NFS客户端以任意账户访问时，映射为NFS服务端的匿名用户（不常用）|
|no_all_squash|当NFS客户端以任意账户访问时，都不进行压缩|
|sync|同时将数据写入内存和磁盘中，保证不丢失数据|
|async|优先将数据写入内存，再写入硬盘；效率更高，可能丢失数据|
|anonuid|配合all_squash使用，指定NFS的用户UID，服务端必须存在该用户|
|anongid|配合all_squash使用，指定NFS的用户GID，服务端必须存在该用户|

示例：验证all_squash、anonuid、anongid权限

```shell
[root@nfs ~]# more /etc/exports
/data/   172.16.1.0/24(rw,sync,all_squash,anonuid=666,anongid=666)

[root@nfs ~]# groupadd -g 666 www
[root@nfs ~]# useradd -u 666 -g 666 www
[root@nfs ~]# chown -R www.www /data
[root@nfs ~]# systemctl restart nfs-server.service

[root@web01 ~]# touch file
[root@web01 ~]# echo "hello" > file
[root@web01 ~]# ll /opt
-rw-r--r--. 1 666 666         6 Nov 30 11:43 file
```

NFS的远程写入，请求到达服务端后会切换成UID为666的用户执行写入操作，所以服务端的www用户一定要有能够操作共享目录的权限，而客户端系统没有UID为666的用户，所以客户端在查看共享目录属性信息的时候，所属组和所属用户都是直接显示数字，而不是显示用户名

### NFS优缺点

NFS存储优点

1. NFS文件系统简单易用、方便部署
2. NFS存放的数据都在文件系统之上，所有数据直观可见

NFS存储局限

1. 存在单点故障，如果构建高可用，维护又比较麻烦 web -> nfs(sersync) -> backup
2. NFS数据明文，不对数据做任何校验
3. 客户端挂载NFS没有密码验证，一般只在内网使用

## Sersync实时同步

只要当前目录发生变化，则会触发一个事件，事件触发后将产生变化的数据同步至远程服务器，这就是实时同步。数据实时同步配合NFS使用，能够解决NFS单点故障问题，除此以外还具备保证数据的连续性、减少人力维护成本等优势

实时同步的实现，需要借助`Inotify`通知接口，用于监控目录的变化，如果被监控的目录发生变更，则触发动作，这个动作可以是进行一次同步操作或其他操作。实时同步工具的选择有`sersync`、`inotify+rsync`，其中sersync是基于`rsync+inotify-tools`开发的工具，其强化了实时监控、文件过滤、简化配置等功能，帮助用户提高运行效率，节省时间和网络资源

[sersync工具](https://github.com/wsgzao/sersync)

### 实时同步实践

实现web上传文件，实则是写入NFS，当NFS存储新数据时触发实时同步操作，复制到备份服务器

|角色|外网IP|内网IP|安装工具|
|---|---|---|---|
|web01|eth0:10.0.0.7|eth1:172.16.1.7|httpd、php|
|nfs-server|eth0:10.0.0.31|eth1:172.16.1.31|nfs-tuils、rsync、inotify、sersync|
|backup|eth0:10.0.0.41|eth1:172.16.1.41|rsync-server|

1. WEB上传文件至NFS

准备NFS服务

```shell
# NFS角色配置
[root@nfs ~]# yum install -y nfs-utils
[root@nfs ~]# more /etc/exports
/data/	172.16.1.0/24(rw,sync,all_squash,anonuid=666,anongid=666)
[root@nfs ~]# groupadd -g 666 www
[root@nfs ~]# useradd -u 666 -g 666 www
[root@nfs ~]# mkdir /data
[root@nfs ~]# chown -R www.www /data

# WEB角色配置
[root@web01 ~]# yum install -y httpd php nfs-utils
[root@web01 ~]# systemctl start httpd
[root@web01 ~]# firewall-cmd --add-service=http --permanent
[root@web01 ~]# firewall-cmd --reload
[root@web01 ~]# mount -t nfs 172.16.1.31:/data /var/www/html/
[root@web01 ~]# more /var/www/html/index.php
<form enctype="multipart/form-data" action="uploadProcess.php" method="post" name="myform">
用户名：<input type="text" name="username" /><br />
密码：<input type="password" name="pwd" /><br />
上传图片：<input type="file" name="upimage"><br />
<input type="submit" name="sub" value="提交">
</form>

[root@web01 ~]# more /var/www/html/uploadProcess.php
<?php
$filetype_arr = array("image/jpeg","image/png","image/gif","image/gif");//允许上传的图片类型
if(!empty($_POST['sub'])){
 $username = $_POST['username'];//用户名
 $password = $_POST['pwd'];//密码
 
 if(is_uploaded_file($_FILES['upimage']['tmp_name'])){//判断是否是通过http上传的图片
  $tmp_name = $_FILES['upimage']['tmp_name'];//上传图片临时名
  //判断图片类型是否支持
  if(!in_array($_FILES['upimage']['type'],$filetype_arr)){
   echo "抱歉，上传图片只支持";
   foreach($filetype_arr as $value){
    echo $value."，";
   }
   echo "等类型";
   exit();
  } 
  $exten_name = substr($_FILES['upimage']['name'],strrpos($_FILES['upimage']['name'],"."));//获取上传图片的后缀名
  $dest_name = $_SERVER['DOCUMENT_ROOT']."/php/upfile/".$username."/";//
  //判断保存的目录是否存在，不存在则创建
  if(!file_exists($dest_name)){
   if(!mkdir($dest_name)){//如果创建不成功
    echo "创建目录失败，文件无法上传";
    exit();
   }
  }
  //如果已经存在保存的目录
  if(move_uploaded_file($tmp_name,$dest_name.time().rand(1,100).$exten_name)){//移动临时文件到保存的目录，并改名
   echo "上传图片成功";
  }else{
   echo "图片上传失败";
  }
 }else{
  echo "找不到你上传的图片，请重新上传";
 }
}
?>
```

2. WEB和NFS的数据都备份到BACKUP的/backup目录

3. NFS的数据实时同步到BACKUP的/data目录