# 容器

在了解Docker的过程中，*容器*是一个避不开的话题。容器泛指任何可以用于容纳其他物品的工具，可以部分或完全封闭，被用于容纳、存储、传输物品，容器可以保护内容物品。容器本身被人类使用已经很长的历史了，其本身并不是一个新概念，而在Linux中，对于容器的了解需要从LXC开始（Linux Container）

## LXC

在学习LXC之前，需要先明确*虚拟化*与*容器*的关系，虚拟化目前主流的实现形式分为*主机级虚拟化*和*容器级虚拟化*

### 主机级虚拟化技术

主机级虚拟化需要模拟整个完整的硬件平台，在主机级虚拟化下又分为以下两种实现类型

- type-Ⅰ：直接在物理机上安装一个虚拟机管理器（Hypervisor） ---- esxi
- type-Ⅱ：在物理机在安装宿主机系统（Host OS），再在宿主机上那幢虚拟机管理器（VMM），在VMM上再创建虚拟机 ---- VMware，virtualbox

无论是哪种实现类型，主机级虚拟化的实现机制都是向用户提供一个完整的硬件平台，用户需要自己安装操作系统、应用程序。传统的虚拟化技术实现了资源的隔离使用，相同的业务应用可以运行在每一个虚拟机内，对于虚拟机而言，这个应用就是唯一的，在宿主机上也不会产生冲突，而实现这些功能的代价就是对宿主机的资源开销

[![虚拟化与容器的关系](https://s1.ax1x.com/2023/01/20/pSGMsxA.png)](https://imgse.com/i/pSGMsxA)

但是，当用户只有少量业务或只有单一业务需要部署时，虚拟化无疑就显得复杂、臃肿了。总所周知，实际产生价值的只有用户空间的业务应用，但用户空间又依赖内核环境。而虚拟化的业务应用运行更是需要经过二级调度，也就是需要经过“两层OS”，这对宿主机资源也会产生额外的损耗

那么现在需要追求的环境就是，既需要对用户空间进行隔离避免业务冲突、又需要缩减虚拟化结构的中间层以提高效率。如上图示例，缩减中间层后启用进程时，让进程启动运行在用户空间中，众多用户空间底层都是被同一个内核管理的，但是，进程运行时能够看到的边界，是自身所处用户空间的边界；综上所述，**每一个用户空间都被用于存放进程，为其提供运行环境，并对其进行隔离保护**，其本质就是容器

显然，用户空间级别隔离没有主机级别隔离的彻底，而且无论怎么对用户环境进行隔离，也一定会有一个特殊的用户空间，用于管理其他用户空间

### 容器级虚拟化技术

```shell
UTS：主机名域名         隔离：主机名和域名
IPC：进程通信专用通道    隔离：信息量、消息对列和共享内存
PID：用户进程           隔离：进程编号
Net：TCP/IP栈           隔离：网络设备、网络栈、端口等
Mount：文件系统         隔离：挂载点
User：用户ID            隔离：用户和用户组
```

内核在最初设计时只是为了支撑单个用户空间的运行，所以在内核级UTS、IPC、PID、Net、Mount、User这6组资源都是独立且只有1组，但是后来有需要运行jail、vserver（chroot）这种早期容器，所以6组资源开始能够在内核级直接切分为多个互相隔离的环境，这个环境就是名称空间。事实上，每一种资源只要在内核级能够直接切分为多个互相隔离的环境，都可以称为名称空间

在内核中，UTS是可以以名称空间为单位进行隔离的，这就意味着，可以在一个内核上创建出多个名称空间，每一个名称空间的UTS资源都相互隔离，所以每一个名称空间都可以有自己独有的主机名、域名；主机名、域名本身是内核级的，所以一台主机上只能有一个主机名，但是现在每一个名称空间都可以有自己的主机名，各个名称空间之间互不干扰，由于内核级的资源切分与隔离，这些名称空间也不会对真正的宿主机名称空间产生影响

为了支撑容器级技术的实现，Linux内核已经通过namespaces机制实现了这6种资源的隔离，也就是说内核级原生支持这6种资源的隔离；但最晚的User资源在内核3.8版本才开始被支持，所以CentOS6天然的就被排除在外了，这并不是说CentOS6就无法使用容器技术，只是在功能上会有缺失

在主机级虚拟化技术的基础上，拔除GuestOS内核，使每个GuestOS上的用户空间都从属于HostOS内核，这种技术就是容器级虚拟化

### CGroups（Control Groups）

解决资源隔离后，容器级虚拟化仍存在一个问题，使用主机级虚拟化，在创建虚拟机的时候就能够限制该虚拟机可使用的最大硬件资源，例如给该虚拟机分配几个CPU核心、多大内存。而容器级虚拟化，名称空间共用HostOS内核，那么如果某一个名称空间内的进程出现BUG，开始吞噬硬件资源，此时就需要内核级再实现一个功能，限制每一个用户空间中的进程的所有可用资源的总量，这个功能在内核级依靠CGroups机制实现

对于CGroups而言，它将系统资源分为多个组，然后将每个组内的资源量分配到各个用户空间的进程上

```shell
blkio：块设备 IO
cpu：CPU
cpuacct：CPU 资源使用报告
cpuset：多处理器平台上得 CPU 集合
devices：设备访问
freezer：挂起或恢复任务
memory：内存用量及报告
perf_event：对 cgroup 中的任务进行同一性能测试
net_cls：cgroup 中的任务创建的数据报文的类别标识符
```

可压缩型资源：例：CPU -- 进程需要 CPU 时如果没有，排列等待即可（挂起）
非可压缩性资源：例：内存 -- 进程需要内存时如果没有，宕机

### LXC（LinuX Container）

早期使用容器技术需要用户自己写代码系统调用，为了简化用户的使用，后来将需要使用容器技术的功能做成了一组工具，于是就产生了一个解决方案LXC，LXC是最早一批把完整的容器技术用一组简易使用的工具和模板实现的方案

LXC可以通过一个命令快速创建一个容器（用户空间），那么这个用户空间内就应该具备最基本的Linux目录结构、基本的应用程序，而创建这些基本环境就需要借助*模板（template）*，template的本质就是一组脚本，LXC工具快速创建一个名称空间实际上也就是给了模板一个执行环境，名称空间创建好之后模板会自动执行实现*安装过程*，这个安装过程实际上也就是模板中会指向将要创建的一类名称空间的系统发行版所属的仓库，从仓库中将各应用程序包下载到本地安装，生成一个新的名称空间，再使用chroot工具进入容器

**template模板的工作流程**

1. LXC工具创建一个名称空间，给了脚本一个执行环境
2. 容器创建好后自动执行模板（脚本）
3. 执行模板的过程中自动实现安装过程
4. 使用 chroot 工具进入容器

使用LXC工具快速创建的名称空间与VMware的虚拟机几乎无差别，但使用LXC依然存在一些问题，LXC对比虚拟机的优势在于，LXC能够让每一个用户空间中的进程直接使用宿主机的性能，中间基本没有额外开销，降低了宿主机的资源开销；虽然LXC工具简化了容器技术的使用，但是LXC比起虚拟机，其复杂程度并没有多少降低，隔离性也没有虚拟机好，除此以外还存在学习成本和使用成本的问题

1. 理解学习各种 LXC 的工具使用
2. 必要时需要自己定制模板
3. 数据迁移不便
4. **批量创建容器不便**

## Docker

由于LXC在大规模使用上仍然没有一个比较好的突破口，于是就产生了Docker，Docker更像是LXC的增强版，其本身也不是容器，而是容器的应用工具，容器是Linux内核的技术，Docker只是将容器技术的使用简化、普及到用户

早期的Docker就是LXC的二次封装，使用LXC作为容器管理引擎，只不过在创建容器时，不再使用模板安装操作系统和应用程序，而是使用镜像技术安装容器环境；镜像技术是指将一个操作系统用户空间所需要用到的所有组件事先编排好后，整体打包成一个文件，称之为镜像文件，镜像文件放在集中统一的一个仓库中，在互联网上有一个公共仓库*dockerhub.com*

早期的Docker操作容器时还是依赖LXC工具进行管理，但Docker创建容器时不会调用模板进行安装，而是连接到镜像仓库，下载匹配创建容器时需要的镜像，并基于此镜像创建容器

LXC是将一个容器当作一个用户空间进行使用，它可以像虚拟机一样，一个容器内可以运行多个进程，这就使得在LXC创建的容器内的管理几乎与虚拟机无差异。而Docker为了使容器更加易于管理，其理念是在一个容器内只运行一个主进程；那么，当容器内的进程出现故障时，LXC容器内的维护工具可以对一个用户空间内的多个进程进行追踪排查。而Docker，维护工具在哪个名称空间中，就只能对那个名称空间中的进程做调试，这就意味着每个Docker容器都需要自带维护工具，维护工具会以子进程的方式存在容器中，平时不会启动

Docker为开发带来了便利，却增加了运维的复杂度

1. 每个容器都是单独的进程，删除与否不影响其他进程
2. 极大降低了软件开发的成本和难度，真正实现了一次编译、到处运行
3. 实现批量创建容器
4. 每启动一个进程就需要新建一个容器，容器内所有的环境都是为进程准备，这也就占用了更多的空间
5. 不利于运维调试
6. 增加了运维环境管理的复杂度

Docker容器本身与主机并没有绑定关系，当容器的数据都挂载到外部存储上时，那么这个容器究竟存在于那个主机上就不重要了，Docker容器的本质就是一组镜像，只要数据还在，那么在任意一台主机上都可以以镜像的方式重启该容器。这种方式适用于单台主机的场景，而涉及到多台主机或集群的场景，就需要使用容器编排工具，常见的编排工具组合：

- machine+swarm+compose
- mesos+marathon
- kubernetes

docker 自主研发的容器引擎：libcontainer --> runC