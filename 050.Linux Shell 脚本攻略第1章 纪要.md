# bash shell命令

在这里记录的shell命令大多都是“常用指令集”的扩展选项，它们在日常管理中不经常出现，但习得它们更有利于管理员做出更加精细化的判断

```shell
# 1.文件扩展匹配用法
ls /home/hebor/D[a-z]*s     # 列出Documents和Downloads目录下的所有文件
ls -l Do[!c]*s      # 取反列出Download目录下的所有文件

# 2.修改文件时间戳
touch -a tmp.text   # 修改文件的访问时间。直接使用touch命令能够变更文件的“修改时间”
ls -l --time=atime  # 查看文件的访问时间。直接使用ls查看到的是文件的“修改时间”
```

管理员面临的最复杂的任务之一就是跟踪运行在系统上的程序，当程序运行在系统上时称其为进程（process）。想监测这些进程，需要熟悉ps命令的用法，它能输出运行在系统上的所有程序的许多信息。
遗憾的是，与它的强大功能相对应的是它的数不清的参数，这或许让ps命令成了最难掌握的命令。大多数系统管理员在掌握了能提供他们需要信息的一组参数之后，就一直坚持只使用这组参数

ps命令复杂的原因是因为它曾经有2个版本，每个版本都有自己的参数集，而现在两个版本被合并成为一个命令，合并的版本也可以看做是一个新版本。所以ps命令的用法实际上有三种风格：Unix风格，前面加单破折线、BSD风格，前面不加破折线、GNU风格，前面加双破折线

```shell
ps -ef  # -e参数显示所有运行在系统上的进程；-f扩展输出
    UID：进程所属用户
    PID：进程ID
    PPID：父进程ID
    C：进程生命周期中的CPU利用率
    STIME：进程启动时的系统时间
    TTY：进程启动时的终端设备
    TIME：运行进程需要的累计CPU时间
    CMD：启动程序的名称
ps -l   # 长输出
    F：内核分配给进程的系统标记
    S：进程的状态。O表示正在运行、S表示休眠、R表示可运行或等待运行、Z表示僵尸进程（进程已结束但父进程已不在）、T表示停止
    PRI：进程优先级（数字越低优先级越高）
    NI：谦让值（用于参与决定优先级）
    ADDR：进程的内存地址
    SZ：假设进程被换出，所需交换空间的大致大小
    WCHAN：进程休眠的内核函数地址
ps l   # 长输出。大部分输出与Unix风格输出一样
    VSZ：进程在内存中的大小，单位是KB
    RSS：进程在未换出时占用的物理内存
    STAT：当前进程的双字符状态码
```

BSD风格的STAT字节所表示的第一个字符采用了与Unix风格的S列相同的值，表明进程是在休眠、运行还是等待。第二个参数进一步说明状态

```
<：该进程运行在高优先级
N：该进程运行在低优先级
L：该进程有页面锁定在内存中
s：该进程时控制进程
l：该进程时多线程的
+：该进程运行在前台
```

另外，GNU风格参数中`--forest`参数会显示进程的层级信息，并通过ASCII字符绘制字符图表

## 格式化输出 

**1. printf**

```shell
printf "%-5s %-10s %-4s\n" No Name Mark
printf "%-5s %-10s %-4.2f\n" 1 Sarath 80.3456 
printf "%-5s %-10s %-4.2f\n" 2 James 90.9989 
printf "%-5s %-10s %-4.2f\n" 3 Jeff 77.564
```

`%s`和`%f`都是格式替换符，`%-5s`表示左对齐5字符替换，`-`表示左对齐，不加`-`表示右对齐，`%4.2f`中的`.2`表示小数点后保留2位；默认printf指令不会自动换行，所以需要`\n`手动换行

**2. 打印彩色输出**

echo -e "\e[1;31m This is test paragraph \e[0m";

## 环境变量

**1. 获取程序PID**

```shell
pgrep gedit
less /proc/PID/environ    # 查看与该进程相关的环境变量
more /proc/1129/environ | tr '\0' '\n'  # 使环境变量变得易读
```

特殊文件`/proc/$PID/environ`是一个包含环境变量以及对应变量值的列表，每个变量以`name=value`的形式来描述，彼此之间由null字符（\0）分隔，直接查看该文件无法直接获取到有用信息

**2. 获取字符串长度**

```shell
fruit=apple,banana,orange
echo ${#fruit}
```

**3. shell内建特性**

```shell
echo $SHELL    # 获取当前shell
echo $UID    # 获取当前账户UID
```

shell参数的一种扩展形式：${parameter:+expression}
如果parameter有值且不为空，则使用expression的值

**4. Bash提示字符串**

```shell
echo $PS1    # 查看当前提示字符串
PS1="[\u@\h]\$ "    # 临时修改PS1，永久修改需要写入/etc/profile
```

## 数学运算

`Bash`使用`let`、`(())`和`[]`执行基本的算数操作。工具`expr`和`bc`可以用于执行高级操作。除了`bc`命令，其他方法都不支持浮点数，只能用于整数运算
```shell
[root@VM-4-2-centos shell]# more count.sh
#!/bin/bash
no1=4;
no2=5;
let result=no1+no2;    # 使用let命令时，变量名不需要再添加$符
echo $result;
result=$[ no1+no2 ]    # 使用操作符[]
result=$(( no1+no2 ))    # 使用操作符(())
result=$(expr $no1 + 5)    # 必须要有空格，否则会被expr命令视作整体

[root@rhel shell]# echo "4 *0.56" | bc    # bc示例
```

**算数的简写形式**

自加/减1：no1++/ no1--

自加/减n：no1+=n/ no1-=n

## 重定向

**1. 双重重定向**

`tee`命令可以实现将数据重定向到文件的同时，想`stdout`也输出同一份数据。标准语法：`Command | tee File1 File2 | OtherCommand`

```shell
more /etc/rc.d/rc.local | tee -a rc.locale
```

注意，`tee`命令只能从`stdin`中读取数据，发送到`stderr`的数据不能被读取。要输出两份副本到`stdout`时，使用`-`替换`tee`后面的文件名即可，例如`tee -`

> **自定义文件描述符**

文件描述符是一种用于访问文件的抽象指示器（abstract indicator）。例如0、1、2分别是stdin、stdout、stderr预留的描述符编号，三者分别代表标准输入模式、标准输出模式、标准错误模式。相比较此三种模式，还有比较常见的三种模式分别是只读模式、追加写入模式、截断写入模式（覆盖写入模式）

通过`exec`命令创建自定义的文件描述符

-<：对应只读模式，用于将文件读入stdin
->：对应截断模式，覆盖目标文件的原内容
->>：对应追加模式，数据追加到文件的原内容之后

示例：创建自定义文件描述符

```shell
exec 3<input.txt    # 使用文件描述符 3 打开并读取文件
echo "This is a test paragraph" > input.txt    # 向文件内写入内容
cat <& 3    # 验证输出文件描述符 3 读取的内容
```

注意，自定义文件描述符仅能使用一次，例如上例，已经使用`cat`命令读取过一次文件描述符3了，无法再继续使用描述符3，而是需要重新通过`exec`命令新建一个描述符

示例：创建截断模式描述符

```shell
exec 4>output.txt    # 打开文件进行写入
echo newline >& 4    # 输出内容到文件描述符
more output.txt    # 检查文件内容
```

## 数组

数组分为2种：普通数组和关联数组

- 普通数组：以整数作为数组索引
- 关联数组：以字符串作为数组索引

示例：定义普通数组

```shell
array_var=(test1 test2 test3 test4)    # 定义数组
# array_var[0]="test1"    另一种定义数组的方式

echo ${array_var[0]}    # 输出数组内的值
echo ${array_var[*]}    # 输出数组内的所有值
echo ${array_var[@]}    # 输出数组内的所有值

echo ${#array_var[@]}    # 输出数组元素个数
```


示例：定义关联数组

```shell
declare -A ass_array    # 声明此数组为关联数组
ass_array=([index1]=var1 [index2]=var2)    # 定义关联数组
echo ${ass_array[index1]}    # 输出数组内的值

echo ${!ass_array[*]}    # 输出数组的所有下标索引。也就是index1、index2
```

关联数组不能直接创建，需要先用命令声明定义关联数组名

## 终端信息

终端信息包括当前终端的行数、列数、光标位置、取消密码回显等。`stty`是终端处理工具

示例：取消密码回显

```shell
#!/bin/bash
#FileName: password.sh
echo -e "Enter password: "
# 禁止回显
stty -echo
read password
# 重新允许回显
stty echo
echo
echo Password read.
```

`stty`命令的`-echo`选项禁止输出发送到终端，`echo`选项则允许发送。使用完`-echo`选项后必须马上使用`echo`，否则后续的命令都不会回显

## 日期及延时

在系统内部，日期被存储为一个整数，其取值为1970年1月1日0时0分0秒起所流逝的秒数。这种计时方式被称为纪元时或Unix时间

```shell
ntpdate -s ntp1.aliyun.com
    -s：将日志输出从标准输出（默认）转移到系统syslog工具。类似静默模式

#!/bin/bash
#filename: sleep.sh
echo Count.
tput sc    # 存储光标位置

#循环10秒
for count in $(seq 0 10)
do
 tput rc    # 每次循环恢复之前存储的光标位置
 tput ed    # 每次循环删除当前光标位置到行尾之间的所有内容
 echo -n $count
 sleep 1
done
```

此脚本意为执行脚本时生成延时。`tput`与`stty`都是终端处理工具

## 调试脚本

脚本调试的3种方法：
1. Bash使用`-x`选项执行脚本
2. 在脚本文件中使用`set -x`和`set +x`命令，局部显示脚本执行过程

```shell
#!/bin/bash -xv
#filename: debug.sh
for i in {1..6};
do
    set -x    # 执行脚本时显示参数和命令
    echo $i
    set +x    # 关闭调试
done
echo "Script executed"
# 整个脚本执行过程中不会显示脚本文件的内容和 set -x 命令
```

3. 使用Bash时直接修改脚本文件的首行注释`#!/bin/bash -xv`

```shell
#!/bin/bash -xv
#filename: debug.sh
for i in {1..6};
do
    echo $i
done
echo "Script executed"

# 脚本执行过程中会将所有执行过程及脚本文件内容全部输出到stdout
```

此处`#!/bin/bash -xv`与命令`set -x -v`含义一致，`-v`选项表示将命令执行时读取的内容输出到stdout

>**补充：CentOS7的环境变量 PS1\~4 含义**

1. PS1：命令提示符变量。默认值`[\u@\h \W]\$`
2. PS2：分行显示的命令提示符。默认值`>`，命令过长时通常将命令分行输入，分行后的命令提示符不再是PS1。使用`export PS2="~ "`修改变量
3. PS3：Shell脚本中使用select命令时的提示符。直接输出$PS3为空，使用select命令时默认提示符是`#?`，可在shell脚本中直接修改PS3的值
4. PS4：Shell脚本调试时的命令提示符。默认值`+`，一般不予修改，脚本调试信息过长时可选择将PS4的值修改为`$LINENO:`输出行号

PS3示例

```shell
#!/bin/bash
#filename: ps3.sh
PS3="Select number (1-3): "    # 修改PS3命令提示符
select i in {1..3}
do
case $i in
  1) echo "1";;
  2) echo "2";;
  3) exit;;
esac
done
```

PS4示例

```shell
#!/bin/bash -x
#filename: debug.sh
PS4='$LINENO: '    # 脚本调试过程显示行号
function DEBUG(){
        [ "$_DEBUG" == "on" ] && $@ || :
}
for i in {1..10}
do
        DEBUG echo "I is $i"
done
# 命令 : 表示不做任何操作并返回0退出码。脚本中在每个echo操作前都添加了函数DEBUG，如果没有将 _DEBUG=on 传递给脚本，那意味着所有echo操作都会转变为 : 命令，无任何输出
```

## 函数与参数

一个函数由5部分组成：function命令、函数名、开/闭括号、花括号、以及被涵盖在花括号内的函数体

定义函数的3种方式：

```shell
# 标准函数定义方式
function fname(){
    statements;
}

# 省略function命令的写法
fname(){
    statements;
}

# 简单函数的写法
fname(){ statement; }

# 调用函数时只需要使用函数名即可
fname   # 执行函数
fname arg1 arg2     # 向函数传递参数
```

实例：shell的位置参数

```shell
#!/bin/bash
#filename: function.sh
fname(){
    echo $1, $2;    # 输出参数1和参数2。$n表示第n个参数
    echo "$@";      # 以列表的方式输出所有参数
    echo "$*";      # 类似$@，单所有参数被视为单个实体
    return 0;       # 返回值
}
fname first second third    # 调用函数
```

"$@"被扩展成"$1" "$2" "$3"等

"$\*"被扩展成"$1c$2c$3"，c是IFS的第一个字符。"$@"比"$\*"更常用

shell预定义变量：

- $#：命令行中位置参数的个数
- $?：上一条命令执行后返回的状态，0表示正常，非0表示异常
- $!：后台运行的最后一个进程号
- $$：当前所在进程的进程号
- $0：当前执行的进程名

### 函数与别名对比

两者非常相似，但在行为上略有不同。最大的差异在于函数参数可以在函数体中任意位置上使用，而别名只能将命令参数放在命令尾部

```shell
# 别名尝试获取IP地址
alias wontWork='/usr/sbin/ifconfig | grep '
wontWork ens33
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500

# 函数尝试获取IP地址
function getIP() { /usr/sbin/ifconfig $1 | grep 'inet '; }
getIP ens33
        inet 192.168.42.210  netmask 255.255.255.0  broadcast 192.168.42.255
```

### 补充：函数技巧

#### 1. 递归函数

递归函数就是能够调用自身的函数。这种函数必须有退出条件，否则就会不断的调用自身，直到系统耗尽所有资源后崩溃

示例：经典递归 Fork炸弹

```shell
:(){ :|:& };:
```

这个函数会一直生成新的进程，最终形成拒绝服务攻击。定义函数名为`:`，通过首次调用函数`:`，函数`:`会不断调用自身并将每次调用自身都通过管道放入后台，不断地衍生出新的进程。为了避免由于递归喊出产生系统故障，可以通过修改配置文件`/etc/security/limits.conf`中的nproc来限制可生成的最大进程数，进而阻止由于递归函数产生的攻击

```shell
vim /etc/security/limits.conf
hard    nproc   100    # 将所有用户可生成的进程数限制为100
```