### 日志管理

此处提及的日志管理与undo、redo等内置工作日志不同，属于可选日志

#### 1. 错误日志

错误日志用于排查MySQL运行过程的故障，其会将MySQL启动以来的所有报错、警告、主从信息都记录到日志文件中；默认情况下开启错误日志，保存路径为`/datadir/$HOSTNAME.err`，错误日志文件默认保存在MySQL数据目录下

```shell
SELECT @@log_error;		#查看错误日志文件路径

[root@VM-4-2-centos data]# vim /etc/my.cnf
[mysqld]
log_error=/tmp/mysql3306.err	#修改错误日志保存路径
```



#### 2. 二进制日志（binlog）

二进制日志是SQL层的逻辑型日志，用于记录操作的SQL语句，默认不开启二进制日志

##### 2.1 作用

1. 主从要依赖二进制日志
2. 数据恢复时需要依赖二进制日志

##### 2.2 二进制日志的记录内容

二进制日志记录了数据库所有的变更类的操作日志，涵盖了DDL、DCL、DML语句，DDL和DCL都会以语句的方式原模原样的记录所有SQL操作语句，对于DML类型的**标准事务语句**

1. 仅记录已提交的事务语句
2. DML语句的记录格式分3种：statement、row、mixed，通过`binlog_format`参数控制
   - statement：SBR，语句模式，以语句的方式原模原样记录所有SQL命令
   - row：RBR，行模式，记录数据行的变化，产生了多少行变化就会记录多少行日志。与redo日志不同的是redo日志记录的是页的变化
   - mixed：MBR，混合模式，由MySQL自行决定用以上那种方式

**SBR与RBR的区别**

SBR：可读性强，对与范围操作日志量少，但可能出现记录不准确的场景（例如数据恢复执行SQL语句，时间对不上）

RBR：保证了数据一致性、准确性；高可用环境中的新特性依赖RBR

##### 2.3 二进制日志记录单元

二进制日志记录的最小单元是**event**（事件），对不同的结构语言记录事件的方式也不同，DCL、DDL每一条SQL语句就是一个事件，DML的整个事务中的所有语句会被单独视为一个事件；例如

```shell
CREATE DATABASE newtable;	#事件1

BEGIN;		#事件1
a			#事件2
b			#事件3
COMMIT;		#事件4
```

且每个事件都有其开始位置和结束位置，通过该两个位置可以单独截取事件中包含的SQL语句

##### 2.4 binlog配置

示例：配置核心参数

```shell
[root@VM-4-2-centos data]# vim /etc/my.cnf
[mysqld]
server_id=		#MySQL5.7 以后的版本要开启binlog必须有此参数
log_bin=/data/binlog/mysql-bin		#参数值为1时表示开启binlog，并将日志文件放至默认路径
binlog_format=row	#默认配置
sync_binlog=1	#每次事务提交时都将内存中的binlog刷写到磁盘；"双一"标准另一个

[root@VM-4-2-centos data]# mkdir /data/binlog/
[root@VM-4-2-centos data]# chown -R mysql.mysql /data/*
[root@VM-4-2-centos data]# ls /data/binlog/
mysql-bin.000001  mysql-bin.index

[root@VM-4-2-centos binlog]# cat mysql-bin.index 
/data/binlog/mysql-bin.000001
```

`log_bin`参数指定的路径目录必须**已存在且可写**，其次`mysql-bin`仅作为`binlog`日志的前缀，实际的日志文件名并不与定义的一致；`mysql-bin.index`文件内保存生成的所有`binlog`日志文件名称，类似于整个`binlog`日志的索引；MySQL仅使用一个日志文件，如果日志目录下生成了多个日志后缀文件，那么一般使用的是最后一个日志文件，可手动进行设置，通过重启服务或刷新日志都可以新生成一个日志文件

示例：二进制日志管理

```shell
--- 查看二进制日志的默认存放路径
SHOW VARIABLES LIKE '%log_bin%';
--- 查看所有已产生的二进制日志
SHOW BINARY LOGS;
FLUSH LOGS;		#滚动一个新的日志
--- 查看目前生效的二进制日志
SHOW MASTER STATUS;

--- 查看二进制日志事件
CREATE DATABASE binlog CHARSET utf8mn4;
USE binlog;
CREATE TABLE t1(id int);
INSERT INTO t1 VALUES(1);

SHOW binlog EVENTS IN 'mysql-bin.000008';	#指定当前生效的日志文件查看事件记录，可以看到以上操作记录
	#Pos：event的开始位置
	#End_log_pos：event的结束位置
COMMIT;
SHOW binlog EVENTS IN 'mysql-bin.000008';
	#未提交的事务不记录，提交后再查看，从begin开始记录整个事务语句，且截取事务event时，必须截取整个事务的开始位置和结束位置
	
--- 查看二进制日志内容
[root@VM-4-2-centos ~]# mysqlbinlog /data/binlog/mysql-bin.000008
...
# at 154
#210709 15:27:22 server id 6  end_log_pos 219 CRC32 0x77bedc30  Anonymous_GTID  last_committed=0        sequence_number=1       rbr_only=no
SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
# at 219
...
	#两个位置之间就是一个事件，直接使用mysqlbinlog命令读取日志内容，事务event中的语句仍然是不可读的
[root@VM-4-2-centos ~]# mysqlbinlog --base64_output=decode-rows -vvv /data/binlog/mysql-bin.000008
	#@1=1：在第1行插入数值1

--- 针对单个库过滤二进制日志
[root@VM-4-2-centos ~]# mysqlbinlog -d test1 /data/binlog/mysql-bin.000008
	
--- 截取二进制日志
[root@VM-4-2-centos ~]# mysqlbinlog --start-position=219 --stop-position=335 /data/binlog/mysql-bin.000008 > /tmp/back.sql
--- 通过binlog恢复数据
[root@VM-4-2-centos ~]# mysqlbinlog --start-position=1414 --stop-position=2011 /data/binlog/mysql-bin.000008 > /tmp/bin.sql		#先截取丢失的日志段
mysql> set sql_log_bin=0;	#临时关闭当前会话的二进制日志记录；因为通过二进制日志恢复数据时，恢复语句也会被记录，为防止冗余，暂时性关闭选项
mysql> source /tmp/bin.sql	#恢复数据
```

通过二进制日志恢复数据没有问题，但考虑到日志量级和性能等，不应该仅使用二进制日志进行数据恢复，而是应该结合备份文件+二进制日志的方式进行数据恢复

##### 2.5 binlog的gtid记录模式管理

`global transaction identifieds`全局事务标识，没有GTID前，`binlog`按事件的起始结束位置规划所有日志内容，开启GTID后，对于`binlog`中的每个事务都会生成一个GTID号；与InnoDB事务不同，对于DDL、DCL语句，一个event就是一个GTID事务，生成一个GTID号，对于DML语句，`begin`到`commit`是一个事务，生成一个GTID号

GTID由2部分组成：`server_id:TID`，`server_id`保存在`/DATADIR/auto.cnf`文件中，TID是一个从1开始的自增长的数据，示例：`238d7541-de0a-11eb-bba2-5254006e53c9:1-15`，此TID表示数据库已经运行了`1~15`个事务了

GTID具有幂等性；拿GTID日志进行数据恢复时，检查当前系统中是否具备相同的GTID号，有相同的GTID号的自动跳过，与Ansible的幂等性相似，此特性会影响到`binlog`的数据恢复和主从复制

示例：GTID的配置

```shell
[root@VM-4-2-centos data]# vim /etc/my.cnf
[mysqld]
gtid-mode=on	#开启GTID模式
enforce-gtid-consistency=true	#强制GTID一致性
	#GTID开启后仅对之后生成的事务生效，之前的事务不变

--- 查看GTID信息
mysql> show master status;	#查看GTID号; Executed_Gtid_Set
mysql> show binlog events in 'mysql-bin.000009';	#查看binlog日志记录的GTID号
	#开启GTID后，每次记录binlog前，都会先生成并记录一个GTID号，用SET声明
```

示例：基于GTID的binlog数据恢复

```shell
[root@VM-4-2-centos binlog]# mysqlbinlog --include-gtids='238d7541-de0a-11eb-bba2-5254006e53c9:1-3' mysql-bin.000009 > /tmp/gtid.sql	#导出gtid 1~3号日志

mysql> set sql_log_bin=0;
mysql> source /tmp/gtid.sql		#导入截取的gtid日志
ERROR 1049 (42000): Unknown database 'gtid'
Query OK, 0 rows affected (0.00 sec)

ERROR 1046 (3D000): No database selected
Query OK, 0 rows affected (0.00 sec)
```

报错，因为GTID的幂等性检查，`1~3`号事务已经存在过了，所以导入GTID日志时会跳过`1~3`号事务

解决：导出GTID日志时忽略原有的GTID信息

```shell
[root@VM-4-2-centos binlog]# mysqlbinlog --skip-gtids --include-gtids='238d7541-de0a-11eb-bba2-5254006e53c9:1-3' mysql-bin.000009 > /tmp/gtid.sql
```

添加`--skip-gitds`参数后，导出的GTID日志中不再记录GTID号，导入日志时则会生成新的GTID号，将GTID日志当作新的事务进行恢复

##### 2.6 GTID相关的参数

`--skip-gtids`：导出GTID日志时忽略GTID信息

`--include-gtids`：声明GTID日志的截取区间

`--exclude-gtids`：跳过指定的GTID日志号不截取日志

示例：截取/跳过多段GTID日志

```shell
--- 截取多段GTID日志
--include-gitds='238d7541-de0a-11eb-bba2-5254006e53c9:6','238d7541-de0a-11eb-bba2-5254006e53c9:8'
--- 跳过多段GTID日志
--exclude-gtids='238d7541-de0a-11eb-bba2-5254006e53c9:6','238d7541-de0a-11eb-bba2-5254006e53c9:8'
```

此处TID号不可使用`1-x`，`-`代表一个区间，要跳过多段日志只能通过`,`进行分隔

##### 2.7 二进制日志清理

1. 自动清理日志

```shell
expire_logs_days=15	#日志最长保留时间；一般配合数据备份时间决定清理时间，清理时间需要大过备份时间
	#例如每7天备份一次日志，那么日志自动清理必须设置7天以上，一般保留两轮全备周期的时长
```

2. 手动清理日志

```shell
mysql> help purge	#查看删除帮助
Examples:
PURGE BINARY LOGS TO 'mysql-bin.010';	#删除到指定文件，但不包括该文件
PURGE BINARY LOGS BEFORE '2008-04-02 22:46:26';		#删除指定时间之前的所有日志

mysql> purge binary logs to 'mysql-bin.000009';

mysql> reset master;	#删除所有日志文件并重新从第一个日志文件开始记录
```

在主从MySQL中的主数据库中执行`reset master`指令会**导致从数据库的崩溃**

3. 日志滚动条件

```shell
1. flush logs;
2. 数据库重启
3. max_binlog_size=1073741824	#默认日志文件大小为1G，文件空间占尽后滚动日志
```



#### 3. 慢日志（slow-log）

`slow-log`用于记录MySQL中运行较慢的语句，是优化过程中常用的日志工具

##### 3.1 配置

```shell
slow_query_log=1	#开启slow-log日志
slow_query_log_file=/data/mysql/slow.log		#slow-log日志文件路径
long_query_time=0.1		#慢查询时间；超过0.1s的语句执行会被记录
log_queries_not_using_indexes		#未走索引的语句也记录

--- 查看慢查询时间
mysql> select @@long_query_time;
```

##### 3.2 模拟慢查询

```shell
--- 以下语句仅用于模拟慢查询，执行无索引、查询时间较长的语句，无其他意义
mysql> select * from t100w where k1='bb' limit 1000,2000;
mysql> select * from t100w where num='16222' order  by k1;
mysql> select * from t100w where num='100' order  by k1;

--- 直接查看慢日志文本内容
[root@VM-4-2-centos mysql]# cat /data/mysql/slow.log
...
# Time: 2021-07-11T02:49:29.961008Z
# User@Host: root[root] @ localhost []  Id:     2
# Query_time: 0.488988  Lock_time: 0.000093 Rows_sent: 0  Rows_examined: 1000000
SET timestamp=1625971769;
select * from t100w where num='16222' order  by k1;
...

--- 通过mysqldumpslow工具分析慢日志
[root@VM-4-2-centos mysql]# mysqldumpslow -s c -t 10 /data/mysql/slow.log
	-s c：表示按次数进行排序，-s 表示排序，c 表示次数
	-t：top 10，仅显示前10条
...
Count: 1  Time=0.50s (0s)  Lock=0.00s (0s)  Rows=2.0 (2), root[root]@localhost
  select * from t100w where num='S' group by k1
...
	Count：1 表示该语句被执行了1次
	Time=0.50s (0s) 表示执行该语句花费的时间
```

通过`mysqldumpslow`工具查看慢日志时，`mysqldumpslow`会自动将`=`或`limit`等一些选项后续条件进行合并，如`num='S'`、`limit N`等，要进行下一步优化时，需要手动为这些选项赋予一个具体的值

##### 3.3 第三方工具扩展

[pt-query-diagest工具下载](https://www.percona.com/downloads/percona-toolkit/LATEST/)

示例：安装第三方工具扩展

```shell
--- 安装依赖
yum install perl-DBI perl-DBD-MySQL perl-Time_HiRes perl-IO-Socket-SSL perl-Digest-MD5

--- 使用工具
pt-query-diagest /data/mysql/slow.log
```

Anemometer基于pt-query-digest将MySQL慢查询可视化

