# 索引

索引类似书的目录，起到优化查询的作用

## 索引算法的分类

MySQL支持很多算法，常见的索引算法有5种

```diff
BTree：默认适用的索引类型
RTree
Hash：自适应hash索引。在InnoDB中也有hash算法，只不过它是存储引擎在索引上自动做的优化，不需要管理
FullText：全文本索引
GIS：善于存储地理位置
```

#### 索引及执行计划

1. 索引的作用

   

2. 索引的分类（算法）

   

##### BTree索引算法

![B-Tree算法](https://gitee.com/hebor/image/raw/main/dba/B-Tree算法.png)

BTree算法分3个阶段：B-Tree -> B+Tree -> B*Tree。此示意图展示的是B-Tree算法，从上往下分为3个层面：**根节点**、**枝节点**、**叶子节点**，每个节点大小都为`16K`，也就是一个页

在B-Tree算法中，枝节点中仅记录每个叶子节点内的最小值和相对应的指针，例如第一个枝节点中记录的`5-P1,10-P2,20-P3`，代表着叶子节点`P1`的最小值是`5`、`P2`的最小值是`10`，依此类推，根节点中记录的则是每个枝节点内的最小值和相对应的指针；数据查询时依次从根节点搜索到叶子节点找到数据

B+Tree基于B-Tree算法对连续查询不间断的数据做出优化，B+Tree算法在叶子节点的`Q`之间添加了双向指针（由于此图是B-Tree算法示意图，仅展示单向指针）；例如，查询`28~38`的数据，如果依靠B-Tree算法查询，那么每查询一个数据就要重新从根节点查询到叶子节点，而B+Tree算法则能够一次获取到叶子节点整页的数据，跨页的再通过`Q`之间的双向指针直接获取，不再重复走根节点

B*Tree则基于B+Tree算法的基础上，在枝节点之间也加上了双向指针

##### BTree索引类型分类

- **辅助索引**

  辅助索引通过5个步骤生成BTree：

  1. 管理员选择源表中的一个列创建辅助索引
  2. MySQL自动将此列的值取出
  3. 将此列值进行自动排序
  4. 将排好序的值均匀的存储到索引的叶子节点
  5. 生成枝节点和根节点

  在BTree的叶子节点中的值，实际上也会指向源表中数据行所在的页码，这样在通过索引查找到该列值的同时，也就获取到了该列值对应的数据行在源表的哪一页中，从而实现快速查询；但这都建立在源表数据所处的页码是顺序排序的，如果页码无序的，那么仍然是需要遍历页码的，只不过在性能上比遍历整个数据表内容要更好

- **聚集索引**

  聚集索引一般使用主键列值，没有主键时选择唯一键，主键在创建时就强制要求数据有序保存，通过主键写入数据时，MySQL自动创建和维护聚集索引，聚集索引的BTree通过主键列创建，其与辅助索引的BTree最大的不同在于，聚集索引的BTree直接将源表作为叶子节点，然后提取聚集索引列向上生成枝节点和根节点

  辅助索引配合聚集索引使用时，先通过辅助索引查找叶子节点中的列值，此时叶子节点中保存的不再是`列值和页码`，而是保存`列值和主键`，找到列值后再通过主键查找到聚集索引中的叶子节点中的数据行

**辅助索引细分**

- 单列辅助索引
- 联合索引（覆盖索引）
- 唯一索引：取唯一键的列值作为索引
- 前缀索引：取列值的前几个字符作为索引

##### 索引树高度

索引树高度应该越低越好，一般维持在3~4层最佳，常见的几种引起索引树层度增高的几种问题：

1. 数据行数较多

   分表：parttion，逻辑上将一个数据量过大的表切成多个小表以提升读写效率，但实际上这多个表还是使用的同一个MySQL实例；此方式用的较少了

   分片（分布式架构，进行分库分表）：为了提升读写量级，实现物理和逻辑上都分离数据量过大的表，通过多个MySQL实例存储分离的小表

2. 字段长度

   尽量选择字符长度短的列作为索引列

   无法选择字符串短的列作为索引列时，采用前缀索引

3. 数据类型

   字符类型优先级从左到右：enum > varchar > char



#### 索引操作命令

---

示例：通过`desc`查看表内索引

```shell
mysql> desc city;
+-------------+----------+------+-----+---------+----------------+
| Field       | Type     | Null | Key | Default | Extra          |
+-------------+----------+------+-----+---------+----------------+
| ID          | int(11)  | NO   | PRI | NULL    | auto_increment |
| Name        | char(35) | NO   |     |         |                |
| CountryCode | char(3)  | NO   | MUL |         |                |
| District    | char(20) | NO   |     |         |                |
| Population  | int(11)  | NO   |     | 0       |                |
+-------------+----------+------+-----+---------+----------------+
```

`key`列的值即表示索引键，此处索引键分3种`PRI`、`MUL`、`UNI`，分别代表`主键索引`、`辅助索引`、`唯一索引`



示例：查看索引的详细信息

```shell
mysql> show index from city;
+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name    | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| city  |          0 | PRIMARY     |            1 | ID          | A         |        4188 |     NULL | NULL   |      | BTREE      |         |               |
| city  |          1 | CountryCode |            1 | CountryCode | A         |         232 |     NULL | NULL   |      | BTREE      |         |               |
+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
```

此查询结果中可以看出`Key_name`键名和`Column_name`该索引所取的列值



示例：创建索引

```shell
mysql> alter table city add index idx_name(name);	#创建单列辅助索引
	#通过alter修改表结构，取name列添加索引，索引名为idx_name
	
mysql> alter table city add index idx_c_p(countrycode,population);	#创建联合索引

mysql> alter table city add unique index uidx_dis(district);	#创建唯一索引
ERROR 1062 (23000): Duplicate entry 'Zuid-Holland' for key 'uidx_dis'
	#建立唯一索引时，表中必须要有唯一键，如果不确定某个列是否唯一，也可以通过此语句测试
	
mysql> alter table city add index idx_dis(district(5));		#创建前缀索引
	#将district列的前5个字符作为前缀索引
	
mysql> alter table city drop index idx_name;	#删除索引
```

示例：百万数据压力测试
```shell
[root@VM-4-2-centos ~]# mysqlslap --defaults-file=/etc/my.cnf \
> --concurrency=100 --iterations=1 --create-schema='test' \
> --query="select * from test.t100w where k2='IJ56'" engine=innodb \
> --number-of-queries=2000 -uroot -predhat -verbose
	#模拟100个用户，向MySQL提起2000次访问
	#iterations：设置整个步骤重复执行的次数，包括准备数据、测试 load、清理
```



##### 执行计划分析

在MySQL服务进程结构中有提及到服务进程分为三层：连接层、SQL层、存储引擎层，执行计划是指SQL语句到了SQL层的预处理步骤时，会对SQL语句进行解析，从而生成多种语句执行计划，再经过评估成本、优化之后得处最高效的执行计划；执行计划分析则是将优化器选择的最优执行计划截取出来，通过管理员判断语句的执行效率

示例：获取执行计划

```shell
mysql> desc select * from test.t100w where k2='IJ56';	#通过desc获取执行计划
mysql> explain select * from test.t100w where k2='IJ56';	#通过explain获取执行计划
```



示例：分析执行计划

```shell
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | t100w | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 997335 |    10.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+

1. table：表名
2. type：扫描的类型
   a. 全表扫描：ALL
   b. 索引扫描：index ，range ，ref ，eq_ref ，const(system) ，NULL ；性能从左至右从低到高
      - index：全索引扫描；查询的数据结果集需要遍历整个索引树
      - range：索引范围扫描；通过where语句非等值查询限制范围
      - ref：辅助索引等值查询
      - eq_ref：多表连接时，子表使用自身的主键列或唯一列作为连接条件
      - const(system)：主键或唯一键的等值查询
      - NULL：查无此数据；查不到数据时不需要回表查询，所以性能最好

3. possible_key：可能会用到的索引；此列可能会有多个值
4. key：实际用到的索引
5. key_len：索引的覆盖长度
6. filtered：符合where子句条件的数据行数占总扫描数的百分比，占比越高越好
7. Extra：Using filesort；在查询过程中出现了额外的排序，索引在构建时本身就是有序了，索引合适的情况下不应该出现此提示
```



##### 补充：range类型不同的SQL语句引起的性能差异

```shell
desc select * from city where id > 2000;
desc select * from city where countrycode like 'CH%';
===
desc select * from city where countrycode='CHN' or countrycode='USA';
desc select * from city where countrycode in ('CHN','USA');
```

上述的4个例子都属于range索引范围扫描，但后者`or`和`in`的性能却要比前者差，因为前者无论是`>`或`like`都属于连续的范围查询，通过`B*Tree`算法可以实现跨枝节点或叶子节点进行连续查询以提升性能；其中`or`语句如果更改为`union all`，则性能会超过前者

对于普通索引或唯一键索引，使用不等查询`!=`或`not in`时，是不走索引的，也就是说`type=ALL`；仅对于主键索引`!=`和`not in`走索引，类型是`range`

对于`like`子句，上述例子中属于`range`类型索引，但将条件内容更改为`'%CH%'`时，则不走索引；在特定情况下将后`%`号前面的字符减少，例如`'CH%'`更改为`'C%'`时，也可能因为模糊范围过大而不走索引

##### 补充：key_len的计算

`key_len`的长度根据创建表时定义的数据类型进行计算，例如指定数据类型`char(2)`，那么`key_len`的长度则是由`char(2)`的*最长字节预留长度* 加*是否为空值的判断值* ，在`utf8mb4`编码下，`char`的*最长字节预留长度* 即每字符占4字节，加上*是否为空值的判断值* 1字节，那么`key_len`长度为9字节；在建表时如果使用了`not null`键，则计算`key_len`长度时不再加上*是否为空值的判断值* ；在`utf8`编码下，中文占3个字节

`int`类型数值*最长字节预留长度* 为4字节；`varchar`类型值*最长字节预留长度* 与`char`一致，但`varchar`会用额外的2个字节用于声明字符开始和字符结束；`char`或`varchar`下的数字实际占用字节仅占1字节

##### 联合索引

使用联合索引时，`key_len`的长度因该是越长越好的，`key_len`越长意味着`select`语句中引用到的索引条件就越多，性能就越高

```diff
- 创建联合索引时，唯一值多的列放在最左侧
```

示例：不同索引条件导致`key_len`的变化

```shell
mysql> alter table city add index idx(name,district,population);
mysql> desc select * from city where name='Kabul' and district='Kabol' and population='1780000';
+----+-------------+-------+------------+------+---------------+------+---------+-------------------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref               | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+-------------------+------+----------+-------+
|  1 | SIMPLE      | city  | NULL       | ref  | idx           | idx  | 59      | const,const,const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+-------------------+------+----------+-------+

mysql> desc select * from city where name='Kabul' and district='Kabol';
+----+-------------+-------+------------+------+---------------+------+---------+-------------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref         | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | city  | NULL       | ref  | idx           | idx  | 55      | const,const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+-------------+------+----------+-------+

mysql> desc select * from city where name='Kabul' and district>'Kabol' and population='1780000';
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | city  | NULL       | range | idx           | idx  | 55      | NULL |    1 |    10.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+


mysql> select length(k2) from test1;	#查看单列值占用的字节数

--- 强制使用指定索引查表
mysql> explain select * from city force index(idx)  where district='Kabol' and population='1780000' and name='Kabul';

--- 忽略指定索引查表
mysql> explain select * from city ignore index(idx_name) where district='Kabol' and population='1780000' and name='Kabul';
```

**关于联合索引的优势**

- 创建联合索引`(a,b,c)`时，实际等同于创建了3个索引：`(a)`、`(a,b)`、`(a,b,c)`，每多一个索引都会增加写操作的开销和磁盘空间的开销，对于大数据场景考虑使用联合索引
- 索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql：`select * from table where a=1 and b=2 and c=3`，假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W×*10%*=100w条数据，然后再回表从100w条数据中找到符合 `b=2 and c= 3` 的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10%×10%×10%=1w，然后再排序、分页，哪个更高效，一眼便知 

**等值连续条件查询**

所有索引列都是等值查询的条件下，可以不关心判断条件的排列顺序，因为优化器会自动按照创建索引时的顺序进行排序；但通过`select`查询数据时，**排在前面的判断条件必须要存在**，例如`idx(name,district,population)`，`name`条件可以排在`select`语句末端，但其必须存在，如果整条`select`语句中不存在`name`条件，那后续即便有其他条件判断，也不会在走索引

**等值不连续条件查询**

条件不连续时，仅会走前部分连续条件的索引，后部分非连续条件不走索引，例如存在`name`条件，但跳过了`district`条件，那么该`select`语句仅会走`name`条件的索引；若要对此类索引查询进行优化，可新建一个索引并对索引条件项进行删减，仅设置`name`和`population`作为条件项

**不等值条件查询**

在`where`查询中如果出现不等值查询条件时，索引只能停留到该条件位置，上述第3例中，`district`使用不等值查询，即便后续还有等值查询也不会再走索引；对此类索引进行优化时，新建一个索引并将非等值查询条件放在索引条件项的最后面

**多子句查询**

未建立索引的情况下使用多子句查询排序时，查询结果会提示`Using filesort`，该提示表示还需要对查询数据结果进行额外的文件排序，而建立联合索引后，此排序将被省略

```diff
- 多子句联合查询时，建立的联合索引必须严格按照顺序写入查询条件列
```

示例：未建立索引的查询

```shell
mysql> desc select * from test1  where k1='aa' order by k2;
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+---------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra                                 |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+---------------------------------------+
|  1 | SIMPLE      | test1 | NULL       | ref  | idx           | idx  | 7       | const |    1 |   100.00 | Using index condition; Using filesort |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+---------------------------------------+
```

示例：建立索引后的查询

```shell
mysql> mysql> desc select * from test1 where k1='aa' order by k2;
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | test1 | NULL       | ref  | idx,idx3      | idx3 | 7       | const |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
```



#### 索引应用规范

##### 建立索引的原则（DBA运维规范）

1. 必须要有主键，如果没有可以作为主键条件的列，创建无关列，自增长
2. 经常做为`where`、`order by`、`group by`、`join on`、`distinct` 的条件列，建立索引
3. 最好使用唯一值多的列作为联合索引前导列，其他的按照联合索引的4个优化细节来做
4. 列值长度较长的索引列，建议使用前缀索引
5. 降低索引条目，一方面不要创建无用的索引，不常使用的索引清理，`percona toolkit (xxx)`
6. 索引维护避开业务繁忙期
7. 小表不建索引



##### 不走索引的情况（开发规范）

1. 没有查询条件，或查询条件没有建立索引
2. 查询结果集是源表中的大部分数据，查询结果集是25%以上时优化器就不走索引了
3. 索引更新不及时导致索引本身失效，统计数据不真实
4. 查询条件使用函数在索引列上，或对索引列进行计算
5. 隐式转换导致索引失效
6. `<>`，`not in` 不走索引（辅助索引）
7. `like '%aa'` 百分号在最前面不走索引

```diff
- 隐式转换：当表中有一列字符串类型的列，用于存储数字类型的数据，查询时既可以加单引号表示字符串查询，也可以不加单引号表示数字查询
- 		  直接使用数字类型查询时，MySQL会先通过内置函数将数字类型转换为字符串类型再进行查询
- 		  所以两者性能完全不一致，字符串查询走的的ref，数字查询则不走索引
```
