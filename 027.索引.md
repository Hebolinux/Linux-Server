# 索引

索引类似书的目录，起到优化查询的作用，索引本质是为了减少MySQL的磁盘I/O，所以小表无需建索引

## 索引算法的分类

MySQL支持很多算法，常见的索引算法有5种

```diff
BTree：默认适用的索引类型
RTree
Hash：自适应hash索引。在InnoDB中也有hash算法，只不过它是存储引擎在索引上自动做的优化，不需要管理
FullText：全文本索引
GIS：善于存储地理位置
```

### BTree索引算法

![B-Tree算法](https://www.z4a.net/images/2023/07/13/B-Tree.png)

BTree算法分3个阶段：B-Tree -> B+Tree -> B*Tree。此示意图展示的是B+Tree算法，从上往下分为3个层面：**根节点**、**枝节点**、**叶子节点**，每个节点大小都为`16K`，也就是一个页

在B-Tree算法中，枝节点中仅记录每个叶子节点内的最小值和相对应的指针，例如第一个枝节点中记录的`5-P1,10-P2,20-P3`，代表着叶子节点`P1`的最小值是`5`、`P2`的最小值是`10`，依此类推，根节点中记录的则是每个枝节点内的最小值和相对应的指针；数据查询时依次从根节点搜索到叶子节点找到数据

B+Tree基于B-Tree算法对连续查询不间断的数据做出优化，B-Tree算法的叶子节点是没有`Q`指针的，B+Tree算法在叶子节点的`Q`之间添加了双向指针（此图箭头未展示完全，应该是双向箭头，仅展示了单向指针）；例如，查询`28~38`的数据，如果依靠B-Tree算法查询，那么每查询一个数据就要重新从根节点查询到叶子节点，而B+Tree算法则能够一次获取到叶子节点整页的数据，跨页的再通过`Q`之间的双向指针直接获取，不再重复走根节点

B*Tree则基于B+Tree算法的基础上，在枝节点之间也加上了双向指针


### BTree索引类型分类

#### 辅助索引

辅助索引通过5个步骤生成BTree：

1. 管理员选择源表中的一个列创建辅助索引
2. MySQL自动将此列的值取出
3. 将此列值进行自动排序
4. 将排好序的值均匀的存储到索引的叶子节点
5. 生成枝节点和根节点

在BTree的叶子节点中的值，实际上也会指向源表中数据行所在的页码，这样在通过索引查找到该列值的同时，也就获取到了该列值对应的数据行在源表的哪一页中，从而实现快速查询；但这都建立在源表数据所处的页码是顺序排序的，如果页码无序的，那么仍然是需要遍历页码的，只不过在性能上比遍历整个数据表内容要更好

##### 辅助索引细分

- 单列辅助索引
- 联合索引（覆盖索引）
- 唯一索引：取唯一键的列值作为索引。唯一索引可能会担任聚集索引，兼容了聚集索引和辅助索引
- 前缀索引：取列值的前几个字符作为索引

#### 聚集索引

聚集索引一般使用主键列值，没有主键时选择唯一键，主键在创建时就强制要求数据有序保存，通过主键写入数据时，MySQL自动创建和维护聚集索引，聚集索引的BTree通过主键列创建，其与辅助索引的BTree最大的不同在于，聚集索引的BTree直接将源表作为叶子节点，然后提取聚集索引列向上生成枝节点和根节点。将源表直接作为叶子节点的方式，也可以反过来说它是没有叶子节点

辅助索引配合聚集索引使用时，先通过辅助索引查找叶子节点中的列值，此时叶子节点中保存的不再是`列值和页码`，而是保存`列值和主键`，找到列值后再通过主键查找到聚集索引中的叶子节点中的数据行

##### 聚集索引与辅助索引的区别

1. 表中任何一列都可以创建辅助索引，有需求的时候一张表中也可以有多个辅助索引，索引名不能重名
2. 一张表中只能存在一个聚集索引，一般是主键列
3. 辅助索引的叶子节点只存储索引列的列值和聚集索引列的列值
4. 聚集索引的叶子节点存储索引列对应的整行数据

##### 索引树高度

索引树高度应该越低越好，一般维持在3~4层最佳，常见的几种引起索引树层度增高的几种问题：

1. 数据行数较多

   分表：parttion，逻辑上将一个数据量过大的表切成多个小表以提升读写效率，但实际上这多个表还是使用的同一个MySQL实例；此方式用的较少了

   分片（分布式架构，进行分库分表）：为了提升读写量级，实现物理和逻辑上都分离数据量过大的表，通过多个MySQL实例存储分离的小表

2. 字段长度

   尽量选择字符长度短的列作为索引列

   无法选择字符串短的列作为索引列时，采用前缀索引

3. 数据类型

   字符类型优先级从左到右：enum > varchar > char

## 索引操作命令

示例：通过`desc`查看表内索引

```shell
mysql> desc city;
+-------------+----------+------+-----+---------+----------------+
| Field       | Type     | Null | Key | Default | Extra          |
+-------------+----------+------+-----+---------+----------------+
| ID          | int(11)  | NO   | PRI | NULL    | auto_increment |
| Name        | char(35) | NO   |     |         |                |
| CountryCode | char(3)  | NO   | MUL |         |                |
| District    | char(20) | NO   |     |         |                |
| Population  | int(11)  | NO   |     | 0       |                |
+-------------+----------+------+-----+---------+----------------+
# `key`列的值即表示索引键，此处索引键分3种`PRI`、`MUL`、`UNI`，分别代表`主键索引`、`辅助索引`、`唯一索引`
```

示例：查看索引的详细信息

```shell
mysql> show index from city;
+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name    | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| city  |          0 | PRIMARY     |            1 | ID          | A         |        4188 |     NULL | NULL   |      | BTREE      |         |               |
| city  |          1 | CountryCode |            1 | CountryCode | A         |         232 |     NULL | NULL   |      | BTREE      |         |               |
+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
# 此查询结果中可以看出`Key_name`键名和`Column_name`该索引所取的列值
```

示例：创建索引

```shell
mysql> alter table city add index idx_name(name);	#创建单列辅助索引
	#通过alter修改表结构，取name列添加索引，索引名为idx_name
	
mysql> alter table city add index idx_c_p(countrycode,population);	#创建联合索引

mysql> alter table city add unique index uidx_dis(district);	#创建唯一索引
ERROR 1062 (23000): Duplicate entry 'Zuid-Holland' for key 'uidx_dis'
	#建立唯一索引时，表中必须要有唯一键，如果不确定某个列是否唯一，也可以通过此语句测试
	
mysql> alter table city add index idx_dis(district(5));		#创建前缀索引
	#将district列的前5个字符作为前缀索引
	
mysql> alter table city drop index idx_name;	#删除索引
```

示例：百万数据压力测试（需要导入[t100w库](https://github.com/hebor/Linux-Server/tree/master/%E9%99%84%E4%BB%B6)）

```shell
[root@db01 ~]# mysqlslap --defaults-file=/etc/my.cnf \
--concurrency=100 --iterations=1 --create-schema='test' \
--query="select * from test.t100w where k2='tu67'" -engine=innodb \
--number-of-queries=2000 -uroot -predhat -verbose
	#模拟100个用户，向MySQL提起2000次访问，无索引情况下执行时间会比较久
	#iterations：设置整个步骤重复执行的次数，包括准备数据、测试 load、清理

# 添加辅助索引后再执行压力测试
mysql> alter table t100w add index idx_k2(k2);
```

### 执行计划分析

在MySQL服务进程结构中有提及到服务进程分为三层：连接层、SQL层、存储引擎层，执行计划是指SQL语句到了SQL层的预处理步骤时，会对SQL语句进行解析，从而生成多种语句执行计划，再经过评估成本、优化之后得处最高效的执行计划；执行计划分析则是将优化器选择的最优执行计划截取出来，通过管理员判断语句的执行效率

示例：获取执行计划

```shell
# 两种语法都是仅获取执行计划，不真正执行语句
mysql> desc select * from test.t100w where k2='IJ56';	#通过desc获取执行计划
mysql> explain select * from test.t100w where k2='IJ56';	#通过explain获取执行计划
```

示例：分析执行计划

```shell
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | t100w | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 997335 |    10.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+

1. table：表名；根据表名能够确定到是那张表出现了问题
2. type：扫描的类型
   a. 全表扫描：ALL；一般检索全表数据、where条件列无索引、语句出现反选符号时都是全表扫描
   b. 索引扫描：index ，range ，ref ，eq_ref ，const(system) ，NULL ；性能从左至右从低到高
      - index：全索引扫描；查询的数据结果集需要遍历整个索引树
      - range：索引范围扫描；通过where语句非等值查询限制范围
      - ref：辅助索引等值查询
      - eq_ref：多表连接时，子表使用自身的主键列或唯一列作为连接条件
      - const(system)：主键或唯一键的等值查询
      - NULL：查无此数据；查不到数据时不需要回表查询，所以性能最好

3. possible_key：可能会用到的索引；此列可能会有多个值
4. key：实际用到的索引
5. key_len：索引的覆盖长度
6. filtered：符合where子句条件的数据行数占总扫描数的百分比，占比越高越好
7. Extra：Using filesort；在查询过程中出现了额外的排序，索引在构建时本身就是有序了，索引合适的情况下不应该出现此提示
```

#### range类型不同的SQL语句引起的性能差异

```shell
desc select * from city where id > 2000;
desc select * from city where countrycode like 'CH%';
===
desc select * from city where countrycode='CHN' or countrycode='USA';
desc select * from city where countrycode in ('CHN','USA');
```

上述的4个例子都属于range索引范围扫描，但后者`or`和`in`的性能却要比前者差，因为前者无论是`>`或`like`都属于连续的范围查询，通过`B*Tree`算法可以实现跨枝节点或叶子节点进行连续查询以提升性能；其中`or`语句如果更改为`union all`，查看执行计划能够看到type从range变为ref，性能会超过前者

对于普通索引或唯一键索引，使用不等查询`!=`或`not in`时，是不走索引的，也就是说`type=ALL`；仅对于主键索引`!=`和`not in`走索引，类型是`range`

对于`like`子句，上述例子中属于`range`类型索引，但将条件内容更改为`'%CH%'`时，则不走索引；在特定情况下将后`%`号前面的字符减少，例如`'CH%'`更改为`'C%'`时，也可能因为模糊范围过大而不走索引

### key_len的计算

key_len的长度根据创建表时定义的数据类型进行计算，例如指定数据类型char(2)，那么key_len的长度则是由char(2)的*最长字节预留长度* 加*是否为空值的判断值* ，在utf8mb4编码下每个中文字符占4个字节，char(2)的最长字节预留长度等于*2字符\*每字符占4字节*，加上*是否为空值的判断值* 1字节，那key_len长度为9字节；在建表时如果使用了`not null`键，则计算key_len长度时不再加上*是否为空值的判断值* ；在utf8编码下，中文占3个字节

`int`类型数值*最长字节预留长度* 为4字节；`varchar`类型值*最长字节预留长度* 与`char`一致，但`varchar`会用额外的2个字节用于声明字符开始和字符结束；`char`或`varchar`下的数字实际占用字节仅占1字节

在utf8mb4编码下，中文1个字符占用4个字节、英文1个字符占用1个字节、数字1个字符占用1个字节，英文与数字明显比中文占用字节更小，但是在设置数据类型的时候，key_len会按最大字符类型来预留字节长度，此处就是按中文字符来预留字节长度

```shell
# k2列有一个辅助索引，通过k2列值观察key_len的变化
mysql> desc t100w ;
+-------+-----------+------+-----+-------------------+-----------------------------+
| Field | Type      | Null | Key | Default           | Extra                       |
+-------+-----------+------+-----+-------------------+-----------------------------+
| id    | int(11)   | YES  |     | NULL              |                             |
| num   | int(11)   | YES  |     | NULL              |                             |
| k1    | char(2)   | YES  |     | NULL              |                             |
| k2    | char(4)   | YES  | MUL | NULL              |                             |
| dt    | timestamp | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |
+-------+-----------+------+-----+-------------------+-----------------------------+

mysql> explain select * from t100w where k2='VWlm';
+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key    | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t100w | NULL       | ref  | idx_k2        | idx_k2 | 17      | const | 1085 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------+

# 在数据较大的表上使用alter修改表结构可以明显感知到锁表的时间变长
mysql> alter table t100w modify k2 char(10) not null;
mysql> explain select * from t100w where k2='MN87';     # 再观察key_len
```

示例：新建测试表观察key_len的计算与变化

```shell
# 新建测试表
mysql> create table test (id int, k1 char(2), k2 varchar(2), k3 char(4), k4 varchar(4)) charset utf8mb4;
mysql> insert into test values(1,'aa','中国','aaaa','中国你好');
mysql> insert into test values(2,'bb','中国','bbbb','中国你好');

#为每一列建立单列辅助索引
mysql> alter table test add index id(id);
mysql> alter table test add index k1(k1);
mysql> alter table test add index k2(k2);
mysql> alter table test add index k3(k3);
mysql> alter table test add index k4(k4);

# int类型数值最长字节预留长度是4字节，判断是否为空占用1字节
mysql> explain select * from test where id=1;
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test  | NULL       | ref  | id            | id   | 5       | const |    2 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------+

# 以中文字符预留最大字节长度，k1字符长度是char(2)，字符编码是utf8mb4，则最大字节长度是8，判断是否为空占用1字节
mysql> explain select * from test where k1='aa';
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test  | NULL       | ref  | k1            | k1   | 9       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------+

# varchar类型值最长字节预留长度与char一致，但varchar会用额外的2个字节用于声明字符开始和字符结束
mysql> explain select * from test where k2='aa';
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test  | NULL       | ref  | k2            | k2   | 11      | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------+

# 联合索引测试，其key_len应该等于所有被匹配到的索引key_len值的总和
mysql> alter table test add index idx(k1,k2,k3,k4);     # 删除此前所有单列索引并创建联合索引
mysql> explain select * from test where k1='aa' and k2='中国' and k3='aaaa' and k4='中国你好';
+----+-------------+-------+------------+------+---------------+------+---------+-------------------------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref                     | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+-------------------------+------+----------+-------+
|  1 | SIMPLE      | test  | NULL       | ref  | idx           | idx  | 56      | const,const,const,const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+-------------------------+------+----------+-------+
# 因此，使用联合索引时，`key_len`的长度是越长越好的，`key_len`越长意味着`select`语句中引用到的索引条件就越多，性能就越高
```

综上所述，单列索引的意义没有特别重要，主要是联合索引的key_len长度应保持越高越好，而单列索引需要注意的则是保持key_len长度应越小越好，这样索引占用的空间会更少

### 联合索引

**创建联合索引时，唯一值多的列放在最左侧**；常见的联合索引查询分为几种情况

#### 等值连续条件查询

所有索引列都是等值查询的条件下，可以不关心判断条件的排列顺序，因为优化器会自动按照创建索引时的顺序进行排序；但通过select查询数据时，**排在前面的判断条件必须要存在**，例如`idx(k1,k2,k3,k4)`，k2条件可以排在select语句任意位置，但其必须存在，如果整条select语句中不存在k2条件，那后续即便有其他条件判断，也不会再走索引

```shell
mysql> explain select * from test where k1='aa' and k3='aaaa' and k2='中国' and k4='中国你好';
+----+-------------+-------+------------+------+---------------+------+---------+-------------------------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref                     | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+-------------------------+------+----------+-------+
|  1 | SIMPLE      | test  | NULL       | ref  | idx           | idx  | 56      | const,const,const,const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+-------------------------+------+----------+-------+
```

#### 等值不连续条件查询

条件不连续时，仅会走前部分连续条件的索引，后部分非连续条件不走索引，例如存在k1条件，但跳过了k2条件，那么该select语句仅会走k1条件的索引；若要对此类索引查询进行优化，可新建一个索引并对索引条件项进行删减，设置idx1(k1,k3,k4)作为条件项

```shell
mysql> explain select * from test where k1='aa' and k3='aaaa' and k4='中国你好';
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | test  | NULL       | ref  | idx           | idx  | 9       | const |    1 |    50.00 | Using index condition |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
```

#### 不等值条件查询

在where查询中如果出现不等值查询条件时，索引只能停留到该条件位置，例如k2使用不等值查询，即便后续还有等值查询也不会再走索引；对此类索引进行优化时，新建一个索引并将非等值查询条件放在索引条件项的最后面，例如idx2(k1,k3,k4,k2)

```shell
mysql> explain select * from test where k1='aa' and k2>'中国' and k3='aaaa' and k4='中国你好';
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | test  | NULL       | range | idx,idx1      | idx  | 20      | NULL |    1 |    50.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+

mysql> select length(k2) from test1;	#查看单列值占用的字节数

# 强制使用指定索引查表
mysql> explain select * from test force index(idx2) where k1='aa' and k3='aaaa' and k4='中国你好' and k2>'中国你好';

# 忽略指定索引查表
mysql> explain select * from test ignore index(idx) where k1='aa' and k3='aaaa' and k4='中国你好' and k2>'中国';
```

#### 多子句查询

多子句指的是一条select语句中存在`group by、order by`等子句的语法，未建立索引的情况下使用多子句查询排序时，查询结果会提示`Using filesort`，该提示表示还需要对查询数据结果进行额外的文件排序，而建立联合索引后，此排序将被省略；多子句联合查询时，建立的联合索引必须严格按照顺序写入查询条件列，例如建立索引idx3(k1,k2)，那么使用select查询语句时k1查询条件必须在k2查询条件前面

```shell
# 删除所有索引，创建idx1(k1)和idx2(k2)两个单列索引
mysql> alter table test add index idx1(k1);
mysql> alter table test add index idx2(k2);
mysql> explain select * from test where k1='aa' order by k2;                                                                                                     
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+---------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra                                 |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+---------------------------------------+
|  1 | SIMPLE      | test  | NULL       | ref  | idx1          | idx1 | 9       | const |    1 |   100.00 | Using index condition; Using filesort |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+---------------------------------------+

# 建立联合索引后的查询
mysql> alter table test add index idx3(k1,k2);
mysql> explain select * from test where k1='aa' order by k2;
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | test  | NULL       | ref  | idx1,idx3     | idx3 | 9       | const |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
```

在创建k2单列索引时，k2列的值其实已经建立过排序了，但在没有联合索引的情况下MySQL的`order by`子句仍会再对其排序，这是因为MySQL应用索引时，同时只能应用到一个，在上例中就是只能应用k1索引，无法应用k2索引

### 关于联合索引的优势

创建联合索引`(a,b,c)`时，实际等同于创建了3个索引：`(a)`、`(a,b)`、`(a,b,c)`，每多一个索引都会增加写操作的开销和磁盘空间的开销，对于大数据场景考虑使用联合索引

索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql：`select * from table where a=1 and b=2 and c=3`，假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W×*10%*=100w条数据，然后再回表从100w条数据中找到符合 `b=2 and c= 3` 的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10%×10%×10%=1w，然后再排序、分页，哪个更高效，一眼便知

## 索引应用规范

### 建立索引的原则（DBA运维规范）

1. 必须要有主键，如果没有可以作为主键条件的列，创建无关列，自增长
2. 经常做为`where`、`order by`、`group by`、`join on`、`distinct` 的条件列，建立索引
3. 最好使用唯一值多的列作为联合索引前导列，其他的按照联合索引的4个优化细节来做
4. 列值长度较长的索引列，建议使用前缀索引
5. 降低索引条目，不要创建无用的索引，不常使用的索引清理，`percona toolkit`工具能够检查索引应用的频率，这类工具能够协助优化索引；如果创建索引的列值经常更新，索引也会更新
6. 索引维护避开业务繁忙期
7. 小表不建索引



### 不走索引的情况（开发规范）

1. 没有查询条件，或查询条件没有建立索引
2. 查询结果集是源表中的大部分数据，查询结果集是25%以上时优化器就不走索引了
3. 在数据表中频繁对列值做更新会导致索引更新不及时，统计数据不真实，进而导致索引本身失效，SQL语句查询变慢
4. 查询条件在索引列上使用函数、或对索引列进行计算会导致MySQL不走索引，例如`where id-99=1;`
5. 隐式转换导致索引失效
6. `<>`，`not in` 不走索引（辅助索引）
7. `like '%aa'` 百分号在最前面不走索引

#### 隐式转换

当表中有一列字符串类型的列，用于存储数字类型的数据，查询时既可以加单引号表示字符串查询，也可以不加单引号表示数字查询。直接使用数字类型查询时，MySQL会先通过内置函数将数字类型转换为字符串类型，然后通过字符串类型结果再到原表中进行匹配，所以两者性能完全不一致，字符串查询走的的ref，数字查询则不走索引

### explain使用场景

1. MySQL出现应急性的查询缓慢
    `show processlist`获取导致数据库出现性能问题的SQL语句
    explain分析该语句的执行计划，有没有走索引，索引的类型情况
    建立索引，修改SQL语句

2. MySQL出现持续性的查询缓慢
    记录慢日志slowlog，分析慢日志
    explain分析该语句的执行计划，有没有走索引，索引的类型情况
    建立索引，修改SQL语句

## 存储引擎引入

MySQL存储引擎相当于Linux文件系统，只不过比文件系统更强大，常见的存储引擎：InnoDB、MyISAM、MEMORY、CSV；第三方的存储引擎：RocksDB、MyRocks、TokuDB，第三方存储引擎压缩比较高、数据的插入性能高、其他功能与InnoDB一致

### truncate

此命令用于删除表数据，其与delete命令的不同在于，delete是逐行的逻辑上的删除，且被删除的数据条目不会立即将存储空间释放，需要做一些手动的碎片清理才能释放空间；truncate命令会将表的区和页进行物理上的清除，立即释放存储空间，但truncate只能以表为单位去删除数据，而delete可以更细致的选择某一数据行进行删除，所以truncate命令需要配合分区表使用

```shell
mysql> truncate TABLE_NAME;
```

### 存储引擎的查看与修改

存储引擎能够基于表级别设置

```shell
mysql> show engines;    # 查看数据库支持的存储引擎
mysql> select @@default_storage_engine;     # 查看默认的存储引擎
mysql> show create table world.city;    # 查看表的存储引擎
mysql> show table status like 'city' \G     # 查看表的存储引擎

# 设置默认的存储引擎
[root@db01 ~]# vim /etc/my.cnf
[mysqld]
default_storage_engine=myisam

mysql> alter table world.city engine=myisam;   # 修改表的存储引擎
```

修改存储引擎的命令还有另外一个作用是整理碎片空间，碎片空间大多是由于一些删除数据的操作产生的，碎片空间的存在会对性能产生一定的影响，整理碎片空间的前提是必须使用InnoDB引擎；还有一种方法整理碎片空间：将原表数据全部导出，删除、新建表，表数据导入，这种方式风险更高，对业务的影响时间也更长

```shell
mysql> alter table world.city engine innodb;
```