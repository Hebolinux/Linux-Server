# MySQL Replication

### 主从复制简介

理论上，如果拥有一个MySQL实例从启动运行到现在的所有的`binlog`，那么该MySQL实例应该可以恢复到任意时刻的状态，主从复制的理念也是借助`binlog`实现，主库数据发生变化产生的`binlog`，传输到从库进行回放，实现在某一时刻上的数据同步，此数据同步非实时同步

1. 主从复制基于binlog实现
2. 主库产生新数据都会记录binlog
3. 从库取得主库的binlog进行回放
4. 主从复制的过程是异步的

### 主从复制的前提

1. 2个或以上的数据库实例
2. 主库需要开启二进制日志，server_id 要不同，区分不同的节点
4. 主库需要建立专用的从库复制用户
5. 从库应该先通过全备主库->恢复的方法进行数据同步
6. 为从库提供主库的配置信息（ip、port、user、passwd、binlog起点）
7. 从库开启专门的复制线程，从全备主库后开始自动同步



## 主从复制搭建

1. 准备多实例

```shell
[root@VM-4-2-centos ~]# pkill mysqld
[root@VM-4-2-centos ~]# systemctl start mysqld3307
[root@VM-4-2-centos ~]# systemctl start mysqld3308
```

2. 检查配置文件

```shell
--- 主库binlog必须开启、server_id必须不同
[root@VM-4-2-centos ~]# cat /data/3307/my.cnf
[mysqld]
user=mysql
datadir=/data/3307/data/
basedir=/application/mysql/
socket=/data/3307/mysql.sock
port=3307
server_id=7
log_error=/data/3307/mysql.log
log_bin=/data/3307/mysql-bin
[mysql]
socket=/data/3307/mysql.sock
```

3. 主库新建专用的从库复制用户

```shell
[root@VM-4-2-centos ~]# mysql -uroot -predhat -S /data/3307/mysql.sock -e "grant replication slave on *.* to repl@'%' identified by 'redhat';"
```

4. 从库恢复主库的全备

```shell
--- 从库恢复的全备不一定是即时的全备，考虑到业务高峰期的性能影响，可使用早期的全备
[root@VM-4-2-centos ~]# mysqldump -uroot -S /data/3307/mysql.sock -A --master-data=2 --single-transaction -R -E --triggers > /tmp/full.sql
[root@VM-4-2-centos ~]# mysql -uroot -S /data/3308/mysql.sock
mysql> set sql_log_bin=0;
mysql> source /tmp/full.sql;
```

5. 为从库提供主库的信息

```shell
---从主库的全备信息获取当前生效的binlog，及LOG_POS号
[root@VM-4-2-centos ~]# cat /tmp/full.sql
-- CHANGE MASTER TO MASTER_LOG_FILE='mysql-bin.000001', MASTER_LOG_POS=154;
[root@VM-4-2-centos ~]# mysql -uroot -S /data/3308/mysql.sock
mysql> \? change master to
CHANGE MASTER TO
  MASTER_HOST='127.0.0.1',
  MASTER_USER='repl',
  MASTER_PASSWORD='redhat',
  MASTER_PORT=3307,
  MASTER_LOG_FILE='mysql-bin.000001',	#主库当前生效的binlog
  MASTER_LOG_POS=154,					#主库的全备信息中的LOG_POS号
  MASTER_CONNECT_RETRY=10;				#网络断开时重连主库的次数
```

6. 开启从库的自动复制线程（实际是开启了IO和SQL两个进程）

```shell
mysql> start slave;

mysql> show slave status \G ;	#检查主从复制状态
	...
	Slave_IO_Running: Yes
	Slave_SQL_Running: Yes
	...
主库：mysql> create database alexsb;
从库：mysql> show databases;

--- 在从库上重新修改主库配置信息
mysql> stop slave;		#停止自动复制
mysql> reset slave all;		#重设所有参数
mysql> \? change master to	#重新加载配置
```

​	补充：主从复制状态不是2个`Yes`时说明出现问题，再往下看观察4个选项排查问题

```shell
Last_IO_Errno: 2003
Last_IO_Error: error connecting to master 'repl@192.168.216.127:3307' - retry-time: 10  retries: 1
Last_SQL_Errno: 0
Last_SQL_Error:
```



## 主从复制工作流程

### 一、主从复制中涉及的文件

```diff
主库：
	binlog
从库：
	relaylog: relay-bin.000001 中继日志
	master.info	保存主库信息的文件
	relaylog.info: relay-log.info relaylog应用的信息
```

### 二、主动复制中涉及的线程

```diff
主库：
	binlog_dump Thread : DUMP_T
从库:
	SLAVE_IO_THREAD : IO_T
	SLAVE_SQL_THREAD : SQL_T
```

### 三、主从复制工作流程

![MySQL主从复制工作原理](https://gitee.com/hebor/image/raw/main/dba/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

1. 从库执行`change master to`命令配置主库的连接信息和`binlog`的复制起点，这些信息会写入`master.info`文件

2. 从库执行`start slave`命令立即开启`IO_T`和`SQL_T`，`IO_T`读取`master.info`获取主库的配置信息
3. `IO_T`请求连接主库，主库专门提供一个`DUMP_T`负责和从库`IO_T`交互
4. `IO_T`根据`master.info`中的`binlog`信息请求主库新的`binlog`
5. 主库产生一个`DUMP_T`线程将最新的`binlog`传输给从库的`IO_T`
6. `IO_T`收到新的`binlog`日志后存储到TCP/IP缓存，并更新`master.info`
7. `IO_T`将TCP/IP缓存中的数据转储到磁盘`relaylog`中
8. `SQL_T`读取`relay.info`获取上次应用的`relaylog`位置信息
9. `SQL_T`按照上次的位置点回放最新的`relaylog`，并再次更新`relay.info`信息
10. 从库自动`purge`应用过的`relaylog`，进行定期清理

##### 补充

1. 从库首次自动同步数据时，`relay.info`中应该是没有记录位置信息的，`SQL_T`会将所有`binlog`回放一遍
2. 主从复制构建成功后，主库产生新的数据后，都会通过`DUMP_T`发送信号给`IO_T`，增强主从复制的实时性
3. 通过`show processlist`可以看到主库上产生的`DUMP_T`线程



## 主从复制故障分析

### 主从复制监控

```shell
mysql> show slave status \G;
---------------------------配置的主控信息------------------------
Slave_IO_State: Waiting for master to send event
Master_Host: 127.0.0.1
Master_User: repl
Master_Port: 3307
Connect_Retry: 10
Master_Log_File: mysql-bin.000001	#此两项信息取自master.info，是最新的日志位置点
Read_Master_Log_Pos: 319			#可用于与主库对比，位置点一样说明同步效率高

-------------------------从库relay应用信息相关-------------------
Relay_Log_File: VM-4-2-centos-relay-bin.000002	#此两项参数说明上次SQL_T已经回放
Relay_Log_Pos: 485								#到relay-bin.000002日志文件的485号
Relay_Master_Log_File: mysql-bin.000001		#声明从库的02号日志文件对应的是主库的01号日志文件

---------------------------从库线程运行状态-----------------------
Slave_IO_Running: Yes
Slave_SQL_Running: Yes
Last_IO_Errno: 0
Last_IO_Error: 
Last_SQL_Errno: 0
Last_SQL_Error:

---------------------------过滤复制相关信息-----------------------
Replicate_Do_DB: 
Replicate_Ignore_DB: 
Replicate_Do_Table: 
Replicate_Ignore_Table: 
Replicate_Wild_Do_Table: 
Replicate_Wild_Ignore_Table: 

-------------------------从库延时主库的时间（秒）-------------------
Seconds_Behind_Master: 0	#从库同步数据的落后时间（被动延时）

------------------------------延时从库---------------------------
SQL_Delay: 0				#设置指定时间后，从库才能同步主库的数据
SQL_Remaining_Delay: NULL

-------------------------GTID复制相关状态信息----------------------
Retrieved_Gtid_Set: 
Executed_Gtid_Set: 
Auto_Position: 0
```

补充：

主从复制中涉及的文件默认都存储在`datadir`下



### 主从复制故障

主从复制故障基本可以定义为涉及到的3个进程发生了故障，这其中主库的`DUMP_T`线程可以忽略不管，因为即便是`DUMP_T`发生了故障，下次从库连接主库时，主库也会重新产生一个`DUMP_T`线程

#### 从库：

##### IO线程故障

1. 连接主库：connecting

   网络断开、连接信息错误或变更、防火墙端口未放开、连接数上限

   排查思路：使用`master.info`的配置信息手动登录MySQL，查看报错信息

2. 请求不到binlog

   binlog 没开、损坏、不存在，主库执行了`reset master`命令

3. 存储binlog到relaylog

   relaylog文件故障，无写入权限



##### SQL线程故障

1. `relay-log`损坏

   此处损坏是指直接`rm`删除`relay-log`文件之类的人为操作，如果通过MySQL删除`relay-log`文件，`relay.info`有感知，则不影响主从复制

2. 回放`relay-log`失败

   执行SQL语句失败（可能是因为从库提前做了变更），线程故障

3. 约束冲突问题（主机、唯一键、非空键）



##### 处理`reset master`问题

```shell
--- 查看从库状态
mysql> show slave status \G ;
	Slave_IO_Running: Yes
	Slave_SQL_Running: Yes
	
--- 主库重置binlog日志
mysql> reset master;

--- 再次查看从库状态，提示找不到对应的主库的binlog文件
	Slave_IO_Running: No
	Slave_SQL_Running: Yes
	Last_IO_Errno: 1236
	Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: 'could not find next log; the first event 'mysql-bin.000001' at 154, the last event read from '/data/3307/mysql-bin.000003' at 154, the last byte read from '/data/3307/mysql-bin.000003' at 154.'
	
--- 重置从库
mysql> stop slave;
mysql> reset slave;
mysql> \? change master to
CHANGE MASTER TO
  MASTER_HOST='127.0.0.1',
  MASTER_USER='repl',
  MASTER_PASSWORD='redhat',
  MASTER_PORT=3307,
  MASTER_LOG_FILE='mysql-bin.000001',
  MASTER_LOG_POS=154,
  MASTER_CONNECT_RETRY=10;
mysql> start slave;
```



##### 处理从库提前变更问题

```shell
--- 从库新建测试库
mysql> create database ceshi;

--- 主库新建库表
mysql> create database ceshi charset utf8mb4;
mysql> use ceshi;
mysql> create table t1 (id int);

--- 检测从库状态
mysql> show slave status \G;
	Slave_IO_Running: Yes
	Slave_SQL_Running: No
	Last_Errno: 1007
	Last_Error: Error 'Can't create database 'ceshi'; database exists' on query. Default database: 'ceshi'. Query: 'create database ceshi charset utf8mb4'

--- 回退从库的提前变更操作
mysql> drop database ceshi;
mysql> start slave;
mysql> show slave status \G;
```



##### 处理约束键冲突问题（例如主键冲突）

```shell
--- 主库新建主键表
mysql> use ceshi;
mysql> create table t2 (id int primary key not null auto_increment);

--- 从库提前变更
mysql> use ceshi;
mysql> insert into t2 values (1);
mysql> commit ;

--- 主库更新数据
mysql> insert into t2 values (1);
mysql> commit ;		#此处检查主从库，数据一致
mysql> insert into t2 values (2);
mysql> commit ;		#从库丢失同步

--- 从库检查状态
mysql> show slave status \G;
	Slave_IO_Running: Yes
	Slave_SQL_Running: No
	Last_Errno: 1062
	Last_Error: Could not execute Write_rows event on table ceshi.t2; Duplicate entry '1' for key 'PRIMARY', Error_code: 1062; handler error HA_ERR_FOUND_DUPP_KEY; the event's master log mysql-bin.000001, end_log_pos 922
	
--- 从库故障处理
mysql> stop slave;
mysql> set global sql_slave_skip_counter = 1;
mysql> start slave;
```



#### 主从故障处理

大多数情况下，SQL_T故障都是由于从库数据提前变更引起的，为了避免这种情况发生：

1. 从库只读

   ```shell
   show variables like "%read_only%";
   	read_only			#普通用户只读
   	super_read_only		#root用户只读
   	#直接写入配置文件重启生效
   ```

2. 使用读写分离中间件（主写从读）

   ```shell
   atlas
   mycat
   ProxySQL
   MaxScale
   ```

##### 合理处理方法

1. 坚持一个原则，一切以主库为准解决问题
2. 如果出现问题，尽量进行反操作
3. 最直接稳妥的方式，重新构建主从

##### 暴力处理主从SQL_T故障

暴力处理方式有风险，最稳妥的方式是重新构建主从

```shell
--- 方式一
stop slave;
set global sql_slave_skip_counter = 1;
	#将同步指针向下移动一个，如果多次不同步时，可重复操作
start slave;

--- 方式二
vim /etc/my.cnf
slave-skip-errors = 1032,1062,1007
	#常见错误代码：
	1007：对象已存在
	1032：无法执行DML
	1062：主键冲突，或约束冲突
```

