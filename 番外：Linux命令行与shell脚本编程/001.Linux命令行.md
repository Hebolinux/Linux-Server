# Linux命令行

在这里记录的shell命令大多都是“常用指令集”的扩展选项，它们在日常管理中不经常出现，但习得它们更有利于管理员做出更加精细化的判断

```shell
# 1.文件扩展匹配用法(通配符)
ls /home/hebor/D[a-z]*s     # 列出Documents和Downloads目录下的所有文件
ls -l Do[!c]*s      # 取反列出Download目录下的所有文件
    # 通配符的正式名称叫作元字符通配符（metacharacter wildcards）

# 2.修改文件时间戳
touch -a tmp.text   # 修改文件的访问时间。直接使用touch命令能够变更文件的“修改时间”
ls -l --time=atime  # 查看文件的访问时间。直接使用ls查看到的是文件的“修改时间”
```

管理员面临的最复杂的任务之一就是跟踪运行在系统上的程序，当程序运行在系统上时称其为进程（process）。想监测这些进程，需要熟悉ps命令的用法，它能输出运行在系统上的所有程序的许多信息。遗憾的是，与它的强大功能相对应的是它的数不清的参数，这或许让ps命令成了最难掌握的命令。大多数系统管理员在掌握了能提供他们需要信息的一组参数之后，就一直坚持只使用这组参数

ps命令复杂的原因是因为它曾经有2个版本，每个版本都有自己的参数集，而现在两个版本被合并成为一个命令，合并的版本也可以看做是一个新版本。所以ps命令的用法实际上有三种风格：Unix风格，前面加单破折线、BSD风格，前面不加破折线、GNU风格，前面加双破折线

```shell
ps -ef  # -e参数显示所有运行在系统上的进程；-f扩展输出
    UID：进程所属用户
    PID：进程ID
    PPID：父进程ID
    C：进程生命周期中的CPU利用率
    STIME：进程启动时的系统时间
    TTY：进程启动时的终端设备
    TIME：运行进程需要的累计CPU时间
    CMD：启动程序的名称
ps -l   # 长输出
    F：内核分配给进程的系统标记
    S：进程的状态。O表示正在运行、S表示休眠、R表示可运行或等待运行、Z表示僵尸进程（进程已结束但父进程已不在）、T表示停止
    PRI：进程优先级（数字越低优先级越高）
    NI：谦让值（用于参与决定优先级）
    ADDR：进程的内存地址
    SZ：假设进程被换出，所需交换空间的大致大小
    WCHAN：进程休眠的内核函数地址
ps l   # 长输出。大部分输出与Unix风格输出一样
    VSZ：进程在内存中的大小，单位是KB
    RSS：进程在未换出时占用的物理内存
    STAT：当前进程的双字符状态码
```

BSD风格的STAT字节所表示的第一个字符采用了与Unix风格的S列相同的值，表明进程是在休眠、运行还是等待。第二个参数进一步说明状态

```
<：该进程运行在高优先级
N：该进程运行在低优先级
L：该进程有页面锁定在内存中
s：该进程是控制进程
l：该进程是多线程的
+：该进程运行在前台
```

另外，GNU风格参数中`--forest`参数会显示进程的层级信息，并通过ASCII字符绘制字符图表

## 环境变量

shell环境变量分两种：*全局变量*和*局部变量*，全局变量对于所有的*shell*和*子shell*都是可见的，局部变量只对创建它们的shell可见。全局环境变量对于那种需要继承父shell信息的程序来说非常有用，管理员可以自定义全局变量或局部变量，通过`set、env、printenv`三个指令能够查看当前shell的环境变量，三者存在细微差异，set能够显示全局变量、局部变量、用户自定义变量并按照字母顺序对结果进行排序，env和printenv都只会输出全局变量

所有的环境变量名均使用大写字符，这是bash shell的惯例。用户自定义的局部变量或shell脚本应该使用小写字符，用户自定义的局部变量应坚持使用小写字符，这能够避免重新定义环境变量可能带来的问题；通过export指令能够将局部变量转变成全局变量，这使得父shell下的子shell也能够使用该变量，子shell能够修改该变量的值或再使用export指令重新定义该变量的值，但这都不会对父shell造成影响，使用export指令定义的全局变量只是临时生效，也可以使用unset指令删除该全局变量

### 环境变量持久化

对于全局变量来说，可能更倾向于将新的或修改过的变量设置放在/etc/profile文件中，但这可不是什么好主意，如果升级了使用的系统发行版，这个文件也会随之更新，那么所有定制过的变量设置可能会全部丢失。所以建议在/etc/profile.d/目录下创建一个以.sh结尾的脚本文件，把新的或修改过的环境变量放在这个文件中

## 构建基本脚本

shell脚本的本质就是将多个命令组合成一个文本文件，从而避免在命令行中逐条执行命令，需要运行这些命令时，只需要运行这个文本文件即可。在创建shell脚本文件时，必须在文件的第一行指定要使用的shell，其格式为`#!/bin/bash`，而接下来的几行可能会通过注释来描述该脚本的一些信息，例如脚本的作用、作者等

shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋值给变量。命令替换可以通过两种方法将命令的输出赋值给变量：反引号字符`` ` ``和`$()`格式。命令替换会创建一个子shell来运行对应的命令，子shell是由运行该脚本的shell所创建出来的一个独立的子shell，也正因如此，该子shell执行命令是无法使用脚本中创建的变量的

在命令行下使用路径`./`执行脚本时，也会创建出子shell；反之，运行命令式不加入路径则不会创建子shell。如果使用的是内建的shell命令，并不会涉及子shell，在命令行下执行脚本时需要留心

### 重定向&管道

比较常见的是输出重定向‘>’和输入重定向‘<’，输出重定向用于将命令执行的结果导入某个文件，而不是直接展示在命令行上，如`who > test1`。输出重定向用于将文件内容作为参数，赋值给命令，如`wc < test1`。还有一种常见但作用不常被提起的重定向：*内联输入重定向*，它使用两个小于号‘<<’，它无需使用文件进行重定向，只需要在命令行中输入用于重定向的数据即可，常见的一种用法就是`cat > test2 << EOF`

实际上EOF并不是固定写法，内联输入重定向需要提供一个文本标记来划分数据输入的开始和结束，这个文本标记可以是EOF，也可以是UFO，如`cat > test2 << UFO`

将一个命令的结果直接重定向到另一个命令，这个过程叫作管道连接。不要认为由管道串起的两个命令会依次执行，Linux系统实际上会同时运行这两个命令，在系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区

### 执行数学运算

对于shell脚本来说，数学运算的处理过程比较麻烦，在shell脚本中有两种途径来执行数学运算

1. expr

    expr允许在命令行上处理数学表达式，并能够识别少数的数学和字符串操作符