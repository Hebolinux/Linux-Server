# 防火墙

防火墙的主要职能是在网络层保障服务器的安全，服务器的安全问题根据不同层面结构划分有不同的解决方式：

- 硬件：保障服务器所处的环境，例如机柜上锁、温度检测、硬件检查
- 网络：iptables/firewalld
- 系统：去除服务器的公网IP、修改SSH端口号、SSH安全相关配置
- 服务：MySQL、Redis，及时更新服务版本，防止已知漏洞被人利用攻击
- 网站：SSL保障网站传输安全、WAF防火墙

firewalld只能实现IP/Port相关的限制，web相关的限制需要借助其他产品实现

## firewalld

CentOS7系统中集成了多款防火墙管理工具，默认启用firewalld动态防火墙管理器（无需重新加载服务使配置生效），firewalld支持CLI、GUI两种管理方式。对于CentOS早期版本使用的防火墙是iptables，虽然从CentOS7默认使用firewalld来看，是鼓励管理员使用firewalld，但是iptables在各个开源软件中仍然使用的比较频繁，建议两者都接触一下

### firewalld区域管理

相较iptables，firewalld支持动态更新，并加入了区域zone的概念。简单描述就是firewalld预先准备了几套防火墙策略模板，管理员可以根据不同的场景选择不同的策略模板，从而实现防火墙策略之间的快速切换。firewalld默认准备了9个区域，这9个区域之间的策略有比较多相同的策略，所以此处仅针对常用的3个区域做解析：trusted（白名单）、public（默认区域）、drop（黑名单）

![firewalld多区域使用规则](https://www.z4a.net/images/2023/04/18/firewalld.png)

注：**一个网卡仅能绑定一个区域、一个区域可以绑定多个网卡**

### firewalld区域配置策略

为了能够正常使用firewalld服务和相关工具去管理防火墙，必须启动firewalld服务，同时关闭iptables相关服务。需要注意firewalld的规则分两种状态：

- runtime运行时：修改规则马上生效，重启服务规则失效，这种方式被作为临时的规则修改测试
- permanent持久配置：修在规则后需要reload重载服务才会生效

```shell
# 1.禁用iptables防火墙服务
[root@m01 ~]# systemctl mask iptables     # 屏蔽iptables服务
[root@m01 ~]# systemctl mask ip6tables

# 2.启用firewalld服务
[root@m01 ~]# systemctl start firewalld
[root@m01 ~]# systemctl enable firewalld

# 3.获取当前默认使用的区域
[root@m01 ~]# firewall-cmd --get-default-zone

# 4.查看当前默认区域配置的所有规则
[root@m01 ~]# firewall-cmd --list-all --zone=public

# 5.拒绝所有主机ssh连接m01节点，仅允许宿主机访问
[root@m01 ~]# firewall-cmd --add-source=10.0.0.254/32 --zone=trusted --permanent
[root@m01 ~]# firewall-cmd --remove-service=ssh --zone=public --permanent
[root@m01 ~]# firewall-cmd --reload

# 6.输出所有活动域
[root@m01 ~]# firewall-cmd --get-active-zone
```

以上示例并无实际意义，因为在这个示例中，trusted区域的默认规则就是放行所有请求，所以从某种角度上看，限制来源IP并无意义。但是这个配置仍然产生了作用，**只要根据来源地址为另外区域设置一个规则（此处表现是为trusted区域设置了一个add-source来源地址），即可实现同时使用多区域规则**，来源IP是10.0.0.254时匹配trusted区域规则，除此以外都匹配public区域规则

#### firewalld常用参数展示

|参数|作用|
|---|---|
|**zone区域相关指令**|
|--get-default-zone|查询默认区域|
|--set-default-zone=<区域名称>|设置默认区域|
|--get-active-zones|展示当前正在使用的区域与对应网卡|
|--get-zones|展示所有区域|
|--new-zone=<zone>|新增区域|
|**services服务相关指令**|
|--get-services|展示默认定义的服务|
|--add-service=<服务名>[,<服务名>]|设置默认区域允许该服务的流量|
|--remove-service=<服务名>|设置默认区域不再允许该服务的流量|
|**Port端口相关指令**|
|--add-port=<端口号/协议>|设置默认区域允许该端口的流量|
|--remove-port=<端口号/协议>|设置默认区域不再允许该端口的流量|
|**Interface网卡相关指令**|
|--add-interface=<网卡名称>|将源自该网卡的所有流量都导向某个指定区域|
|--change-interface=<网卡名称>|将该网卡与区域关联|
|**其他指令**|
|--list-all|展示当前区域的详细信息|
|--reload|使"--permanent"的配置规则立即生效，并覆盖当前配置规则|

#### firewalld自定义服务

```shell
# 1.查询firewalld包相关信息，可以查到默认的区域、服务的xml文件路径
[root@m01 ~]# rpm -ql firewalld

# 2.创建xml配置文件，配置文件本身的名字就是防火墙需要放行的服务名称
[root@m01 ~]# cp /usr/lib/firewalld/services/{http.xml,hebor.xml}
[root@m01 ~]# vim /usr/lib/firewalld/services/hebor.xml
<?xml version="1.0" encoding="utf-8"?>
<?xml version="1.0" encoding="utf-8"?>
<service>
  <short>hebor</short>
  <description>this is test services</description>
  <port protocol="tcp" port="10050"/>   # 需调整协议与端口
</service>

# 3.使用规则
[root@m01 ~]# firewall-cmd --add-service=hebor --permanent
[root@m01 ~]# firewall-cmd --reload

# 4.m01节点安装zabbix-agent，使用其他节点测试端口
[root@web01 ~]# telnet 172.16.1.61 10050
```

### 防火墙端口转发策略

防火墙端口转发指传统的目标地址映射，实现外网访问内网资源

```shell
[root@m01 ~]# firewall-cmd --add-forward-port=port=2222:proto=tcp:toport=22:toaddr=172.16.1.7 --permanent   # 添加端口转发规则
[root@m01 ~]# firewall-cmd --add-masquerade --permanent     # 开启IP地址伪装
[root@m01 ~]# firewall-cmd --reload 
```

![firewalld端口映射](https://www.z4a.net/images/2023/04/19/firewalld.png)

firewalld节点收到客户端的2222端口的ssh请求后，将ssh请求转发到web节点，这个过程是没有问题的，但网络通信都是双向的，客户端通过`10.0.0.0`地址段访问web节点，web节点也应该向`10.0.0.0`地址段返回相应信息，但web节点并没有去往`10.0.0.0`地址段的主机的路由，所以客户端的请求到达web节点后默认会被丢弃，这也就造成了客户端无法正常ssh链接web节点

为了防止以上情况的出现，在firewalld上应该启用IP地址伪装（masquerade），firewalld接收到客户端的请求后，将源IP修改为自身的`172.16.0.0`地址段再去请求web节点，web节点接收到请求后会将响应报文发送给firewalld，再由firewalld将响应报文转发给客户端，实现客户端与web节点之间的通信；这个过程也可以通过在web节点上指定一条路由，所有去往`10.0.0.0`地址段都指向firewalld节点

注：以上解析不能以现有的架构测试出结果，因为web节点也处于`10.0.0.0`地址段，即便firewalld不启用地址伪装也能够实现客户端与web节点的通信

### firewalld富规则

