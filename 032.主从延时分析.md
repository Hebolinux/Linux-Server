# 主从延时监控及原因

---

## 主库原因

1. `binlog`写入磁盘不及时

   ```shell
   sync_binlog=1	#磁盘落地，事务提交时即可写入磁盘，值是0时由OS缓存决定何时写入磁盘
   ```

2. `DUMP_T`串行传输速率慢

   考虑到事务的执行需要区分**先后顺序**，`DUMP_T`以事件为单位传输`binlog`，只能单个事件串行传输`binlog`，并发事务量大或事务规模较大时，可能出现传输日志较慢的情况

   **同一时间点**的多个事务同时提交，必须开启GTID和`双一`，使用`group commit`方式提交事务，可以支持`DUMP_T`并行传输日志，`DUMP_T`并行传输数据的前提是以事务为单位，而不是事件，所以必须开启GTID
   
   ```shell
   mysql> show variables like '%group_commit%';
   +-----------------------------------------+-------+
   | Variable_name                           | Value |
   +-----------------------------------------+-------+
   | binlog_group_commit_sync_delay          | 0     |		#等待传输事务时间，以毫秒为单位
   | binlog_group_commit_sync_no_delay_count | 0     |		#等待传输事务数量
   +-----------------------------------------+-------+
   	#两者结合使用表示 将指定时间内达到一定数量的事务分组提交
   ```
   
   

## 从库原因

主从复制工作流程中`IO_T`线程仅负责从主库获取`binlog`并写入到`relaylog`中，所以`IO_T`线程一般不会导致延时，从库延时的大部分原因是由于`SQL_T`线程导致的

1. 传统复制的单SQL线程

   主库的`DUMP_T`线程可以通过调整配置做到并行传输`binlog`，但从库中的`SQL_T`线程只有一个，无论接收到多少`binlog`，都只能以串行的方式回放事务

   解决方法：

   5.6 版本中新增了GTID功能，可以实现多SQL线程，但只能基于不同库的事务进行并发回放，是库级别的并发（database）；5.6 版本的GTID功能不够完善，对于同一个库下的多个事务，例如`建表-写入-删表`，仅靠GTID无法辨别其先后执行顺序，所以同一个库下产生的事务仍只能串行回放

   5.7 版本中增强了GTID的功能，增加了`seq_no`，增加了新型的并发SQL线程模式（logical_clock），又称MTS技术；`seq_no`可以看作是序列号，5.6 版本中由于GTID仅记录线程的ID号，所以同一个线程下（也就是同一个库下）无法区分事务执行的先后顺序，5.7 版本中GTID不仅记录线程ID号，还记录线程下执行事务的序列ID，实现针对事务级别的并发

   ```shell
   show variables like '%worker%';
   +------------------------+-------+
   | Variable_name          | Value |
   +------------------------+-------+
   | slave_parallel_workers | 0     |		#从库并发SQL线程数，默认为0，表示只有1个SQL线程
   +------------------------+-------+
   1 row in set (0.00 sec)
   ```


2. 主从硬件差异过大
3. 主从参数配置不同
4. 从库和主库的索引不一致



## 主从延时监控

1. 查看从库同步落后时间

   ```shell
   Seconds_Behind_Master: 0	#从库同步数据的落后时间（被动延时）
   ```

2. 主库监测：对比主库和从库之间传输数据是否及时

   ```shell
   mysql> show master status \G ;
                File: mysql-bin.000003		#主库binlog文件
            Position: 457					#主库position号
   
   
   mysql> show slave status \G ;
                 Master_Log_File: mysql-bin.000003		#从库已经获取到的主库binlog文件
             Read_Master_Log_Pos: 457					#从库已经获取到的position号
   ```

3. 从库监测：日志回放是否正常

   ```shell
   mysql> show slave status \G 
                 Master_Log_File: mysql-bin.000003
             Read_Master_Log_Pos: 457		#已获取到的position号
             
                  Relay_Log_File: VM-4-2-centos-relay-bin.000002
                   Relay_Log_Pos: 583		#回放到的position号
                   
   --- 查看binlog与relaylog的对应关系
   [root@VM-4-2-centos ~]# cat /data/3307/data/relay-log.info 		
   ./VM-4-2-centos-relay-bin.000002
   583		#回放过的relaylog
   mysql-bin.000003
   457		#上面relaylog所对应的binlog的position号
   
   mysql> show relaylog events in  'VM-4-2-centos-relay-bin.000002';	#对比relaylog和binlog日志的position号
   +--------------------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+
   | Log_name                       | Pos | Event_type     | Server_id | End_log_pos | Info                                                              |
   +--------------------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+
   | VM-4-2-centos-relay-bin.000002 | 552 | Xid            |      3306 |         457 | COMMIT /* xid=47 */                                               |
   +--------------------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+
   	#Pos表示relaylog的 起始position号
   	#End_log_pos表示binlog的 结束position号
   ```

   

# 延时从库

备份可以用于解决两种类型的故障：物理故障和逻辑故障，原生态的主从复制针对由于物理故障导致的数据丢失能起到较好的作用，对于逻辑故障则需要配置延迟从库，延时从库主要是延迟了`SQL_T`线程执行日志回放的时间点，对于主库产生的事务仍然是正常获取写入`relaylog`

示例：延时从库配置

```shell
mysql> stop slave ;
mysql> change master to master_delay = 300;		默认单位为秒
mysql> start slave ;
```

示例：通过延时从库解决逻辑故障

```shell
mysql> show slave status \G ;
SQL_Delay: 300		#设置的SQL延时时长
SQL_Remaining_Delay: NULL	#最近的事务剩余多少秒后执行
```

## 延时从库恢复

### 恢复思路

1. 监控主库产生了逻辑故障

2. 停止从库的`SQL_T`进程，记录已经回放的位置点

   ```shell
   mysql> stop slave sql_thread;
   ```

3. 截取relaylog

   ```shell
   --- 获取relaylog日志起点
   mysql> show slave status \G ;
   Relay_Log_File: VM-4-2-centos-relay-bin.000002		#relay日志文件
   Relay_Log_Pos: 473		#日志起点
   
   --- 获取relaylog日志终点
   mysql> show relaylog events in 'VM-4-2-centos-relay-bin.000002';
   ```

4. 模拟`SQL_T`线程回放主库日志，跳过逻辑故障点

   手动模拟`SQL_T`线程回放日志势必需要截取`position`号，尾部`position`也可以通过主库查看，然后对应到`relaylog`，头部`position`可以在从库的`relay-log.info`文件中查看，日志内容需要在从库的`relaylog`中截取

5. 恢复业务

   场景一：主从结构中只有一个主库时；从库直接替代主库继续工作

   场景二：主从架构中存在多个主库时；从库导出故障库，还原到主库中

### 故障示例

#### 主库：

```shell
create database delay charset utf8mb4 ;
use delay ;
create table t1 (id int) ;
insert into t1 values (1),(2),(3) ;
commit ;
drop database delay;
```

#### 从库：

1. 停止SQL线程，获取relaylog起点

   ```shell
   mysql> stop slave sql_thread;		#单独停止SQL_T线程
   mysql> show slave status \G ;		#获取relay日志起点
   Relay_Log_File: VM-4-2-centos-relay-bin.000002
   Relay_Log_Pos: 473
   ```

2. 获取relaylog终点

   ```shell
   mysql> show relaylog events in 'VM-4-2-centos-relay-bin.000002';
   +------------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
   | Log_name         | Pos  | Event_type     | Server_id | End_log_pos | Info                                                               |
   +------------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
   | mysql-bin.000003 | 1283 | Query          |      3306 |        1378 | drop database delay                                                |
   +------------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
   ```

3. 截取relaylog

   ```shell
   mysqlbinlog --start-position=473 --stop-position=1283 /data/3307/data/VM-4-2-centos-relay-bin.000002 > /tmp/relay.sql
   ```

4. 恢复relaylog到从库

   ```shell
   mysql -uroot -S /data/3307/mysql.sock
   set sql_log_bin=0 ;
   source /tmp/relay.sql ;
   ```



## 过滤复制

过滤复制与延时从库不能同时存在于同一个节点，所以前面配置的延时从库需要清空配置信息，重置主从；过滤复制会尽可能减小主从之间的压力，从库会有选择性复制主库中的部分数据；过滤复制可以选择配置主库或从库

示例：主库配置

 ```shell
--- 写入my.cnf的选项配置，仅使用其中一个选项；如果有多个库，则需要用多行选项，不能用逗号隔开
binlog_do_db=world		#白名单，仅记录world数据库的日志
binlog_ignore_db=		#黑名单，仅不记录指定的库
 ```

示例：从库配置

```shell
--- 写入my.cnf的选项配置，也可以通过change master to指定，全小写
--- 库级别的黑/白名单
replicate_do_db=
replicate_ignore_db=

--- 表级别的黑/白名单
replicate_do_table=
replicate_ignore_table=

--- 模糊限制名单，例如某个库下以t开头的表
replicate_wild_do_table=
replicate_wild_ignore_table=
```

### 故障示例

示例：过滤复制仅备份`bb`库的数据

```shell
--- 从库配置
[root@VM-4-2-centos ~]# vim /data/3307/my.cnf
[mysqld]
replicate_do_db=bb

--- 主库测试
mysql> create database aaa;
mysql> show master status \G ;
File: mysql-bin.000002
Position: 350

--- 从库检测；从库看不到aaa库，但对比主从库position号可以看出来从库已经获取到日志了
mysql> show slave status \G ;
Master_Log_File: mysql-bin.000002
Read_Master_Log_Pos: 350

--- 测试bb库
mysql> create database bb;	#主库创建
mysql> show databases;		#从库查看
```

注：原本测试库名字是`repl`，从库能够正常获取到主库的日志，但不知为何从库无法将`repl`库恢复出来，更换了几次库名都能够正常恢复，就`repl`无法恢复出来

